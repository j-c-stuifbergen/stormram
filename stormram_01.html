<html><!DOCTYPE html>
<html>
<body>

<h2>JavaScript Arrays</h2>

<p id="text_out"></p>
<p id="pict_out"></p>

<script>

function vector(x,y,z)
{
	this.x = x;
	this.y = y;
	this.z = z;

	this.norm= function()
	{ return Math.sqrt(x*x+y*y+z*z); 
	};

	this.plus = function(vec_b)
	{	return new vector(x+vec_b.x,y+vec_b.y,z+vec_b.z);
	}
	this.minus = function(vec_b)
	{	return new vector(x-vec_b.x,y-vec_b.y,z-vec_b.z);
	}
	this.times = function(scalar)
	{	return new vector(x*scalar,y*scalar,z*scalar);
	}
	this.ip= function(vec_b)
	{ return this.x*vec_b.x + this.y*vec_b.y +this.z*vec_b.z;
	};

	this.cos= function(vec_b)
	{	ip = this.ip(vec_b);
		return ip / (this.norm()*vec_b.norm());
	}
	this.componentOf = function(vec_b)
	/* return component of vec_b along this vector*/
	{
		return this.ip(vec_b)/this.norm();
	}
	this.phi= function(vec_b)
	{	return Math.acos(this.cos(vec_b));	
	}
	this.ordinates = function()
	{	n=4;
		return [x.toFixed(n),y.toFixed(n),z.toFixed(n)];
	}
}
function polar_vectorbycos(r,cosTheta,sinTheta, cosPhi, sinPhi)
{
	return new vector(sinTheta*cosPhi, sinTheta*sinPhi, cosTheta).times(r);
}
function polar_vector(r,theta,phi)
{
	return polar_vectorbycos(r,Math.cos(theta),Math.sin(theta),Math.cos(phi),Math.sin(phi));
}
/** @param {number} a - side of a triangle
* @param {number} b - side of a triangle
* @param {number} hypotenusa - third side of a triangle
* returns the cosine of the angle between sides a and b of a triangle
*/
function cosine(hypotenusa,a,b)
{
	return (-Math.pow(hypotenusa,2)+Math.pow(a,2)+Math.pow(b,2))/(2*a*b);
}

function next_estimate(L5, AD, x, y, z)
{
	var y2 = y-AD;
	vec_AD = [0,-AD, 0];
	vec_B5_A = [x,y,z];
	vec_B5_D = [x,y-AD,z];

}

function height(x,y)
{
   var r2;
   var result=0;
        r2 = Math.pow(x-2.5,2) +Math.pow(y-3.0,2);
         result+= 3.0* Math.exp(-2.50*r2);
        r2 = Math.pow(x-1.0,2) +Math.pow(y-0.5,2);
        result+= 8.5* Math.exp(-2.8*r2);
    return result;
}

function bins(start,end,N,x)
{
    var width=(end-start)/N;
    var y= new Array(N+1);
    y[0]=0.5*height(x,start);
    for(var i=1;i<N;i++)
    {
        y[i]=y[i-1]+ height(x,i*width);
   //     displayText +=" . . . "+ y[i].toExponential(5);
    }
    y[N]=y[N-1]+ 0.5*height(x,N*width);

    return y;
}

function scaled_random(min,max)
{   return min+Math.random()*(max-min);
}
var z=[];
var nBins=1000;
var nResults = 400;
var xMin=0;
var xMax=5.0;
displayText ="";

var x=[];

    var    r =scaled_random(xMin,xMax);

    for(var i=0;i<nResults;i++)
    {
      //displayText += "<br> r="+r+"<br>";
        z=bins(xMin,xMax,nBins,r);
        r=scaled_random(0,z[nBins]);
	    
        var j=1;
        while(z[j]<r && j<nBins)
        {
            j++;
        }
        x[i] =xMin+(xMax-xMin)/nBins*(j- 1);
        r =x[i];
    }
    for(var i=0;i<nResults;i++)
    {
      displayText += "<br>"+x[i];
    }



/** sketch:
   A   D

     O                  B
* the vector from A to D is fixed (horizontal, of fixed length)).
* O and B are fixed points.
* known distances:
* BD is known
* OA is known
* The distance AB is be calculated by an iterative process
*/

displayText = "";

var vecO = new vector(0,0,0);
var vecA = new vector(0,10,3);
var vecD = new vector(0,10,0);
var vecAD = vecD.minus(vecA);// = new vector(0,0,-3);

var B0 = 15; // fixed position between B5 and the axis
var vecB5 = new vector (0,0,-B0);//  polar_vector(B0,Math.PI/2,Math.PI/2);
var R = vecA.norm();// // to be calculated from the triangle B1 B2
var BD = vecB5.minus(vecD).norm(); // to be calculated from the position of A
var BA = vecB5.minus(vecA).norm(); // solution
var vecAB =vecB5.minus(vecA);
displayText += "solution for vecAB = "+ vecAB.ordinates() +"<br>";
displayText += "solution for BA = "+ BA +"<br>";
displayText += "solution for BD = "+ BD +"<br>";
displayText += "coordinates: <br>";
displayText += "origin: "+vecO.ordinates()+" <br>";
displayText += "A: "+vecA.ordinates()+" <br>";
displayText += "B5: "+vecB5.ordinates()+" <br>";
displayText += "D: "+vecD.ordinates()+" <br>";
displayText += "vecAD: "+vecAD.ordinates()+" <br>";

 BA = BD;// -vecAD.norm(); // to be calculated from the position of A

var nIterations = 20;
for (var i = 0; i<nIterations ; i++)
{
        displayText += "iteration = "+ i+"<br>";
	var cosB0 = cosine(B0,R,BA);
	displayText += "cosB0 = "+ cosB0 + " angle is "+ Math.acos(cosB0)+ " <br>";
	displayText += "controle: sinB0 / B0 = "+Math.sqrt(1-cosB0*cosB0)/B0+ " <br>";
	var cosR = cosine ( R,BA,B0);
	displayText += "cosR = "+ cosR + " angle is "+ Math.acos(cosR)+ " <br>";
	displayText += "controle: sinR / R = "+Math.sqrt(1-cosR*cosR)/R+ " <br>";
	var cosBA = cosine(BA,B0,R);
	var theta = Math.acos(-cosBA);
	displayText += "cosBA = "+ cosBA + " angle is "+ theta + " <br>";
	displayText += "controle: sinBA / BA = "+Math.sqrt(1-cosBA*cosBA)/BA+ " <br>";
	vecA = polar_vector(R,theta,Math.PI/2);
	vecD = vecA.plus(vecAD);

	displayText += "coordinates: <br>";
	displayText += "origin: "+vecO.ordinates()+" <br>";
 	displayText += "A: "+vecA.ordinates()+" <br>";
 	displayText += "B5: "+vecB5.ordinates()+" <br>";
 	displayText += "D: "+vecD.ordinates()+" <br>";

	// set new BA for better approximation
	vecAB = vecB5.minus(vecA);
  	    displayText += "vector AB = "+ vecAB.ordinates() +"<br>";
     	vecD = vecA.plus(vecAD)
			     vecDB = vecB5.minus(vecD);
	BA = vecAB.ip(vecAD)/vecAB.norm() + vecAB.cos(vecDB)*BD;
 	displayText += "BA: "+BA+" <br>";
}

document.getElementById("text_out").innerHTML = displayText;

</script>

</body>
</html>

</script>
