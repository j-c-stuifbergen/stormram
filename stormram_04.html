<html><!DOCTYPE html>
<html>
<body>

<h2>JavaScript Arrays</h2>

<p id="pict_out">
<svg id="3Dscreen" width="400" height="400" viewbox="-200 -200 400 400" onmousedown='alert("mouse down in svg! good!")'>
  <circle id="center" cx="-0" cy="00" r="4" stroke="#999" stroke-width="4" fill="green" />
</svg>
</p>
<p id="message">Hier kan een foutmelding komen </p><hr>
<p id="text_out"></p>

<script>

function vector(x,y,z)
{
	this.x = x;
	this.y = y;
	this.z = z;

	this.norm= function()
	{ return Math.sqrt(x*x+y*y+z*z); 
	};

	this.plus = function(vec_b)
	{	return new vector(x+vec_b.x,y+vec_b.y,z+vec_b.z);
	}
	this.minus = function(vec_b)
	{	return new vector(x-vec_b.x,y-vec_b.y,z-vec_b.z);
	}
	this.times = function(scalar)
	{	return new vector(x*scalar,y*scalar,z*scalar);
	}
	this.ip= function(vec_b)
	{ return this.x*vec_b.x + this.y*vec_b.y +this.z*vec_b.z;
	};

	this.cos= function(vec_b)
	{	ip = this.ip(vec_b);
		return ip / (this.norm()*vec_b.norm());
	}
	this.componentOf = function(vec_b)
	/* return component of vec_b along this vector*/
	{
		return this.ip(vec_b)/this.norm();
	}
	this.phi= function(vec_b)
	{	return Math.acos(this.cos(vec_b));	
	}
	this.ordinates = function()
	{	n=7;
		return [x.toFixed(n),y.toFixed(n),z.toFixed(n)];
	}
}
function polar_vectorbycos(r,cosTheta,sinTheta, cosPhi, sinPhi)
{
	return new vector(sinTheta*cosPhi, sinTheta*sinPhi, cosTheta).times(r);
}
function polar_vector(r,theta,phi)
{
	return polar_vectorbycos(r,Math.cos(theta),Math.sin(theta),Math.cos(phi),Math.sin(phi));
}
/** @param {number} a - side of a triangle
* @param {number} b - side of a triangle
* @param {number} hypotenusa - third side of a triangle
* returns the cosine of the angle between sides a and b of a triangle
*/
function cosine(hypotenusa,a,b)
{
	return (-Math.pow(hypotenusa,2)+Math.pow(a,2)+Math.pow(b,2))/(2*a*b);
}

function find_vecA(B0,R,BA)
{
	var cosBA = cosine(BA,B0,R);
	var theta = Math.acos(-cosBA);
	// displayText += "cosBA = "+ cosBA + " angle is "+ theta + " <br>";
	return polar_vector(R,theta,Math.PI/2);
}

/* find an better estimate for BA, given estimates for vecA and vecD,
	satisfying given values for vecB5 and BD
*/
function estimate_BA(BD,vecB5,vecA,vecD)
{
		vecAB = vecB5.minus(vecA);
	        vecDB = vecB5.minus(vecD);
		return vecAB.ip(vecD.minus(vecA))/vecAB.norm() + vecAB.cos(vecDB)*BD;
}
/** param {string} id - should be unique
 * param {array} start - x,y,z
 * param { array} end - x, y , z
 */
function line_object(svg_object, id, start, end)
{
	this.id = id;
	this.start = start;
	this.end = end;

	// this.Mproject = [ [0,1,0],[0,0,z]]; // project on x-y plane
	// create
	// append

	this.rotate = function(Mrot)
	{
		var s=[];
		var e=[];
		
		for( var i = 0;i<this.Mrot.length;i++)
		{	
			s[i] = 0; e[i]= 0;
			for (var j=0;j<Mrot[i].length;j++)
			{
				s[i] += Mrot[i][j]*this.start[j];
				e[i] += Mrot[i][j]*this.end[j];
			}
		}
		// svg description for a straight line from s to e
		var d = "L "+s[0]+" "+s[1]+" "+e[0]+" "+e[1]
		// set attribute in svg element: d= .....
	}
}

function Matrix_display(M)
{	result = "[";
	if (0<M.length)
	{
		result +=" [ "
		if (0<M[0].length)
		{
			result += M[0][0];
			for (j =1; j<M[0].length; j++)
			{
				result += ", "+M[0][j];
			}
		}
		result += " ]"
			
		for (i =1; i<M.length; i++)
		{	
			result +=",<br> \n [ "
			if (0<M[i].length)
			{
				result += M[i][0];
				for (j =1; j<M[i].length; j++)
				{
					result += ", "+M[i][j];
				}
			}
			result += " ]"
		}
	}
	result += " ] <br> \n";
	return result;
}
				
function Matrix_add(M1,M2)
{
	if (M1.length != M2.length)
	{
		alert ("non-compatible matrix sizes");
		return ;
	}
	result = [];
	for( var i = 0;i<M1.length;i++) // number of rows in the result
	{	
		if (M1[i].length != M2[i].length)
		{
			alert ("non-compatible matrix sizes in row "+i);
			return ;
		}
		result[i]=[];
		for (var j=0;j<M1[i].length;j++) // number of columns in the result
		{
			result[i][j]=M1[i][j]+M2[i][j];
		}
	}
	return result;

}
function Matrix_subtract(M1,M2)
{
	if (M1.length != M2.length)
	{
		alert ("non-compatible matrix sizes");
		return ;
	}
	result = [];
	for( var i = 0;i<M1.length;i++) // number of rows in the result
	{	
		if (M1[i].length != M2[i].length)
		{
			alert ("non-compatible matrix sizes in row "+i);
			return ;
		}
		result[i]=[];
		for (var j=0;j<M1[i].length;j++) // number of columns in the result
		{
			result[i][j]=M1[i][j]-M2[i][j];
		}
	}
	return result;
}
function Matrix_multiply(M1,M2)
{
	if (M1[0].length != M2.length)
	{
		alert ("non-compatible matrix sizes");
		return 0;
	}
	result = [];
	for( var i = 0;i<M1.length;i++) // number of rows in the result
	{	
		result[i] = [];
		for (var j=0;j<M2[0].length;j++) // number of columns in the result
		{
			result[i][j]=0;
			for (var k = 0; k<M2.length; k++) // M2.length = M1[i].length
			{
				result [i][j]+= M1[i][k]*M2[k][j];
			}
		}
	}
	return result;

}
/* perform repeated small rotation around x and z axis
*/
function Matrix_rotate(M_in,nPhi,nTheta)
{
	var N = 20; // 20 small rotations along 2 different axes
	
	var delta = 0.02 ;// standard angle of rotation, in radians
	delta1 = delta * nTheta/N;
	delta2 = delta * nPhi/N;
	cosT = Math.cos(delta1);
	sinT = Math.sin(delta1);
	cosP = Math.cos(delta2);
	sinP = Math.sin(delta2);

	// the generators of the rotations
	// = matrices for small rotations
	// theta: rotate along z axis 
	M_theta = [ [ cosT, sinT  , 0],
		    [ -sinT , cosT  , 0],
		    [     0,   0   , 1] ];
	// phi: rotate along y axis
	M_phi = [ [ cosP, 0, sinP],
		  [ 0,    1,   0 ],
		  [ -sinP,0, cosP] ];
   	M_combined = Matrix_multiply(M_theta,M_phi); 
	// displayText += "Mcombined is "+Matrix_display(M_combined);
	// for small values of delta, M_theta x M_phi = M_phi x M_theta
	var M = M_in
	for (var k =0; k<N; k++)
	{
		M = Matrix_multiply(M_combined,M);
	}
	return M;
}
/* wrap an array into a more-dimensional array */
function vector_to_matrix(vector)
{
	var result = [];
	for (var i =0; i<vector.length ; i++)
	{
		result[i]=[vector[i]];
	}
	return result;
}

var svgNameSpace = "http://www.w3.org/2000/svg";
 var svg = document.getElementById("3Dscreen"); //Get svg element

function lineSegment(from,to, color)
   {
   	this.setFrom = function(from)
   	{
   		this.from = vector_to_matrix(from) ; // [[x], [y], [z]]
   	}
   	this.setTo = function(to)
   	{	this.to = vector_to_matrix(to); //  [[x], [y], [z]]

   	}
	this.setFrom(from);
	this.setTo(to);
	
	this.element = document.createElementNS(svgNameSpace, 'path'); //Create a path in SVG's namespace
	this.element.style.stroke = color; //Set stroke colour
	this.element.style.strokeWidth = "5px"; //Set stroke width
	// this.element.setAttribute("d","M 0 0 L 100 100"); //Set path's data
	svg.appendChild(this.element);
   	
	
   	this.setAtrb=function(attribute,value)
	   {	this.element.setAttributeNS(null,attribute,value);
	   }
   	/** @params {array} M_rotation - 3 x 3 matrix
   	*   @params {array} center - 	the center of the rotation, and of the projection
   	*/

   	this.project = function(M_rotation,center)
   	{	var from = Matrix_subtract(this.from,vector_to_matrix(center));
			from =Matrix_multiply(M_rotation,from);
   		var to = Matrix_subtract(this.to,vector_to_matrix(center));
   			to = Matrix_multiply(M_rotation,to);
		var pathDef = "M "+from[0][0]+" "+from[1][0]+" "+to[0][0]+" "+to[1][0]+" ";
   // alert ("from is "+Matrix_display(from)+"to is "+Matrix_display(to)+ "center is" + Matrix_display(center)+"<br>Pathdef is " + pathDef);
		this.element.setAttribute("d",pathDef); //Set path's data
	}
   		
   }
/** param {number} nIterations - an integer
* param {number} B0 - 
* param {number} R
* param {number} BA
* param {vector} vecAD - for the moment, a constant value
* find the correct coordinates for A, based on B0 and R and BD.
*/

function solveB5(nIterations, B0,R,BD,vecAD)
{
	var infoText = "";
	var BA = BD; // intial estimate for BA
	var vecB5=new vector (0,0,-B0);
	for (var i = 0; i<nIterations ; i++)
	{
		infoText += "iteration = "+ i+"<br>";
		var vecA = find_vecA(B0,R,BA);	
		var vecD = vecA.plus(vecAD); // this will be more complicated function later
		// set new BA for better approximation
		BA = estimate_BA(BD,vecB5,vecA,vecD);

		infoText += "A: "+vecA.ordinates()+" <br>";
		infoText += "D: "+vecD.ordinates()+" <br>";

		infoText += "BA: "+BA+" <hr>";
	}
	return { text: infoText,
		 vecA: vecA, vecD:vecD
		};
}

/** sketch:
   A   D

     O                  B
* the vector from A to D is fixed (horizontal, of fixed length)).
* O and B are fixed points.
* known distances:
* BD is known
* OA is known
* The distance AB is be calculated by an iterative process
*/




displayText = "";

function svgObjects()
{
   // because positive y is down on the screen
this.Mat_orient =	[ [ 1,  0  , 0],
	[   0, -1  , 0],
	[   0,   0   , 1] ];  
this.Mat_projection =	[ [ 0,  0  , 1],
	[   0, 1  , 0],
	[   0,   0   , 0] ];

this.center = [20,40,0]

this.segments = []; // array of lineSegments

this.segments[this.segments.length] = new lineSegment([20,40,0],[80,40,0],"#F00");
this.segments[this.segments.length] = new lineSegment([20,40,0],[20,100,0],"#080");

this.segments[this.segments.length] = new lineSegment([20,40,0],[20,40,60],"#008");

	this.rotate = function(down,right)
	{
		// Mat_projection = Matrix_multiply(this.Mat_projection,this.Mat_orient);

		this.Mat_orient = Matrix_rotate(this.Mat_orient, down,right);
		let Mat_projection = Matrix_multiply(this.Mat_projection,this.Mat_orient);
   		for( let i = 0; i<this.segments.length; i++)
   		{
		this.segments[i].project(Mat_projection,this.center);
   		}
	
	}
	this.alert = function()
	{ alert ( "Mat_projection is <br>" + Matrix_display(this.Mat_projection) + "<hr>");
	}
}

//var vecO = new vector(0,0,0);
var vectorA = new vector(0,10,3);
var vectorD = new vector(0,10,0);
var vectorAD = vectorD.minus(vectorA);// = new vector(0,0,-3);

var B0 = 15; // fixed position between B5 and the axis
var vectorB5 = new vector (0,0,-B0);//  polar_vector(B0,Math.PI/2,Math.PI/2);
var R = vectorA.norm();// // to be calculated from the triangle B1 B2
var BD = vectorB5.minus(vectorD).norm(); // to be calculated from the position of A
var BA = vectorB5.minus(vectorA).norm(); // solution
displayText += "coordinates: <br>";
displayText += "A: "+vectorA.ordinates()+" <br>";
displayText += "B5: "+vectorB5.ordinates()+" <br>";
displayText += "D: "+vectorD.ordinates()+" <br>";
displayText += "solution for BA = "+ BA +"<br>";
displayText += "solution for BD = "+ BD +"<br>";

BA = BD;// -vecAD.norm(); // to be calculated from the position of A
displayText += "We will start the iteration with BA = "+ BA +"<hr>";

displayText += solveB5(20, B0,R,BD,vectorAD).text;

document.getElementById("text_out").innerHTML = displayText;

testSVG = new svgObjects();
var mouseX, mouseY;

function rotateSVG(down,right)
{	testSVG.rotate(down,right);
}
rotateSVG(-8,5);

 var svgSun = document.getElementById("bigSun"); //Get svg element
 //svg.addEventListener('mousedown',mouseIsDown);
   svg.setAttributeNS(null,'onmousedown',"mouseIsDown(evt)");
   svg.setAttributeNS(null,'onmouseup',"mouseIsUp(evt)");
// svg.addEventListener('mouseUp',mouseIsUp);
function mouseIsDown(e)
{	
  	takeCoordinates(e)
	svg.setAttributeNS(null,'onmousemove',"mouseHasMoved(evt)");
}
function takeCoordinates(e)
{
	mouseX =   e.clientX||e.changedTouches[0].clientX;
	mouseY =   e.clientY||e.changedTouches[0].clientY;
}
function mouseIsUp(e)
{
   svg.setAttributeNS(null,'onmousemove',null);
}
function mouseHasMoved(e)
{
	oldX= mouseX;
	oldY= mouseY;
	takeCoordinates(e)
	document.getElementById("message").innerHTML =
   	"  mouse to ( "+mouseX +" , "+mouseY+" ) from"+ "(" +oldX +" , "+oldY+" )"; 
	rotateSVG(mouseX-oldX,mouseY-oldY);
}

/* m.b.t. de plaatjes, draaien etc:
- op het svg-element moeten events geregistreerd worden:
	- in status "normal": onMouseDown: set state="rotate"
	- in status "rotate: onMouseMove: change pictures
		onMouseUp: set state="normal"
		onMouseOut: set state="normal"
- rotation:
	the "d" attribute of each path element must be updated.
	The program must have an array that contains for each path:
	- the id attribute (e.g. id = "vecA", "axis_x")
	- the start coordinates
	- the end coordinates
	so the "d" attribute can be calculated.

	The projection from 3D to 2D is a parallel projection.
	So essentially, just the x and y coordinates,
	after the rotation has been performed.
	
	Rotations are the product of small rotations along y-axis (phi) 
	and x-axis (theta).
	The resulting rotation matrix is stored, and when state=="rotate"
	this matrix is updated every time when the mouse is moved.
*/
</script>

</body>
</html>

</script>
