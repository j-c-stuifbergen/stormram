<html><!DOCTYPE html>
<html>
<body>

<h2>JavaScript Arrays</h2>

<p id="pict_out">
<svg id="3Dscreen" width="400" height="400" viewbox="-200 -200 400 400" onmousedown='alert("No function is activated by clicking the mouse.")'>
  <circle id="center" cx="-0" cy="00" r="4" stroke="#999" stroke-width="4" fill="green" />
</svg>
</p>
<p id="message">Hier kan een foutmelding komen </p><hr>
<p id="text_out"></p>
<script type="text/javascript" src="js/MatrixUtil2.js"></script>
<script type="text/javascript" src="js/VectorUtil.js"></script>
<script>

function vector(coordinates)
{
	this.vector = coordinates;
	this.norm= function()
	{  	let sum = 0;
		for (let i = 0; i<this.vector.length; i++)
		{ 	sum += this.vector[i]*this.vector[i];
		}
		return Math.sqrt(sum);
	};

	this.plus = function(vec_b)
	{	result = Array(this.vector.length);
		for (let i = 0; i<this.vector.length; i++)
		{ 	result[i]= this.vector[i] +vec_b.vector[i];
		}
		return new vector(result);
	}
	this.minus = function(vec_b)
	{	result = Array(this.vector.length);
		for (let i = 0; i<this.vector.length; i++)
		{ 	result[i]= this.vector[i] -vec_b.vector[i];
		}
		return new vector(result);
	}
	this.times = function(scalar)
	{	result = Array(this.vector.length);
		for (let i = 0; i<this.vector.length; i++)
		{ 	result[i]= this.vector[i] * scalar;
		}
		return new vector(result);
	}
	this.ip= function(vec_b)
	{  	let sum = 0;
		for (let i = 0; i<this.vector.length; i++)
		{ 	sum += this.vector[i]*vec_b.vector[i];
		}
		return sum;
	};


	this.cos= function(vec_b)
	{	ip = this.ip(vec_b);
		return ip / (this.norm()*vec_b.norm());
	}
	this.phi= function(vec_b)
	{	return Math.acos(this.cos(vec_b));	
	}
	this.toString = function()
	{	return VectorUtil.AsString(this.vector);
	}
}
function polar_vectorbycos(r,cosTheta,sinTheta, cosPhi, sinPhi)
{
	return new vector([sinTheta*cosPhi*r, sinTheta*sinPhi*r, cosTheta*r]);
}
function polar_vector(r,theta,phi)
{
	return polar_vectorbycos(r,Math.cos(theta),Math.sin(theta),Math.cos(phi),Math.sin(phi));
}
/** @param {number} a - side of a triangle
* @param {number} b - side of a triangle
* @param {number} hypotenusa - third side of a triangle
* returns the cosine of the angle between sides a and b of a triangle
*/
function cosine(hypotenusa,a,b)
{
	return (-Math.pow(hypotenusa,2)+Math.pow(a,2)+Math.pow(b,2))/(2*a*b);
}

/* find a better estimate for BA, given estimates for vecA and vecD,
	satisfying given values for vecB5 and BD
	by comparing the length of vecctor from B5 to D
	with BD.
*/
function estimate_BA(BD,vecB5,vecA,vecD)
{
		vecAB = vecB5.minus(vecA);
		// vecABunit = vecAB.times(1/vecAB.norm());
	        vecDB = vecB5.minus(vecD);
		vecAD = vecD.minus(vecA);
		
		// if BD = vecDB.
		return 	(vecAB.ip(vecAD) + 
			 vecAB.ip(vecDB) /vecDB.norm() * BD
			)/vecAB.norm();
		/*return vecABunit.ip(vecAD) + 
			vecABunit.ip(vecDB) * BD/vecDB.norm();
		*/
}

function find_vecA(B0,R,BA)
{
	var cosBA = cosine(BA,B0,R);
	var theta = Math.acos(-cosBA);
	return polar_vector(R,theta,Math.PI/2);
}

/* perform repeated small rotation around x and z axis
*/
function Matrix_rotate(M_in,nPhi,nTheta)
{
	var N = 20; // 20 small rotations along 2 different axes
	
	var delta = 0.02 ;// standard angle of rotation, in radians
	deltaPhi = delta * nPhi/N;
	deltaTheta = - delta * nTheta/N; // negative, because y-coordinates are mirrored in svg
	cosP = Math.cos(deltaPhi);
	sinP = Math.sin(deltaPhi);
	cosT = Math.cos(deltaTheta);
	sinT = Math.sin(deltaTheta);

	// the generators of the rotations
	// = matrices for small rotations
	// theta: rotate along z axis 
	M_theta = [ [ cosT, sinT  , 0],
		    [ -sinT , cosT  , 0],
		    [     0,   0   , 1] ];
	// phi: rotate along y axis
	M_phi = [ [ cosP, 0, sinP],
		  [ 0,    1,   0 ],
		  [ -sinP,0, cosP] ];
   	M_combined = MatrixUtil.Multiply(M_theta,M_phi); 
	// displayText += "Mcombined is "+MatrixUtil.AsHMTL(M_combined);
	// for small values of delta, M_theta x M_phi = M_phi x M_theta
	var M = M_in
	for (let k =0; k<N; k++)
	{
		M = MatrixUtil.Multiply(M_combined,M);
	}
	// make the rows orthonormal, because
        // after many rotations, round-off errors may have accumulated
	for(var i = 0; i<M.length; i++)
        {
               for (var j = 0; j<i; j++)
               { 
                        M[i]=VectorUtil.Subtract(M[i],
                               VectorUtil.TimesScalar(M[j],
                                 VectorUtil.InnerProduct(M[i],M[j])));
               }
        }


	return M;
}

var svgNameSpace = "http://www.w3.org/2000/svg";

/** param {svgObject} svg - a reference tot the svgObject 
 * param {array} from - x,y,z
 * param { array} to - x, y , z
 */

function lineSegment(svgObject,from,to, color)
   {
   	this.from = from; // [x,y,z]
   	this.to = to; // [x,y,z]

	this.element = document.createElementNS(svgNameSpace, 'path'); //Create a path in SVG's namespace
	this.element.style.stroke = color; //Set stroke colour
	this.element.style.strokeWidth = "5px"; //Set stroke width
	
   	this.setAtrb=function(attribute,value)
	   {	this.element.setAttributeNS(null,attribute,value);
	   }
   	/** @params {array} M_rotation - 3 x 3 matrix
   	*   @params {array} center - 	the center of the rotation, and of the projection
   	*/

   	this.project = function(M_rotation,center)
   	{	var from = VectorUtil.Subtract(this.from,center);
			from =MatrixUtil.TimesVector(M_rotation,from);
   		var to = VectorUtil.Subtract(this.to,center);
   			to = MatrixUtil.TimesVector(M_rotation,to);
		var pathDef = "M "+from[0]+" "+from[1]+" "+to[0]+" "+to[1]+" ";
		this.element.setAttribute("d",pathDef); //Set path's data
	}
   		
   }
function svgObjects()
{
// private variables
var svg = document.getElementById("3Dscreen"); //Get svg element
var Mat_orient =	[ [ 1,  0  , 0],
	[   0, 1  , 0],
	[   0,   0   , 1] ];  
var Mat_projection_init =	[ [ 0,  0  , 1],
	[   0, -1  , 0],
	[   0,   0   , 0] ];

var Mat_projection = MatrixUtil.Multiply(Mat_projection_init,Mat_orient);
	this.svg = function ()
	{	return svg;
	}
   // because positive y is down on the screen
  var that = this; 

center = [20,40,0]

this.setCenter=function(xyz)
        {       if (3 == xyz.length)
                {       center = xyz;
                }
        }
        this.segments = []; // array of lineSegments

	this.addSegment = function (from,to,color)
	{
		let count = this.segments.length;
		this.segments[count] = new lineSegment(that,from,to,color);
		svg.appendChild(this.segments[count].element);
		this.segments[count].project(Mat_projection,center);
	}
	this.rotate = function(down,right)
	{

		Mat_orient = Matrix_rotate(Mat_orient, down,right);
                Mat_projection = MatrixUtil.Multiply(Mat_projection_init,Mat_orient);
   		for( let i = 0; i<this.segments.length; i++)
   		{
		this.segments[i].project(Mat_projection,center);
   		}
	
	}
}

testSVG = new svgObjects();
	testSVG.addSegment([20,40,0],[80,40,0],"#F00");
	testSVG.addSegment([20,40,0],[20,100,0],"#080");
	testSVG.addSegment([20,40,0],[20,40,60],"#008");
testSVG.setCenter([15,40,0]); 
testSVG.rotate(-8,5);
var mouseX, mouseY;


svg = testSVG.svg();
   svg.setAttributeNS(null,'onmousedown',"mouseIsDown(evt)");
   svg.setAttributeNS(null,'onmouseup',"mouseIsUp(evt)");
function mouseIsDown(e)
{	
  	takeCoordinates(e)
	svg.setAttributeNS(null,'onmousemove',"mouseHasMoved(evt)");
}
function takeCoordinates(e)
{
	mouseX =   e.clientX||e.changedTouches[0].clientX;
	mouseY =   e.clientY||e.changedTouches[0].clientY;
}
function mouseIsUp(e)
{
   svg.setAttributeNS(null,'onmousemove',null);
}
function mouseHasMoved(e)
{
	oldX= mouseX;
	oldY= mouseY;
	takeCoordinates(e)
	document.getElementById("message").innerHTML =
   	"  mouse to ( "+mouseX +" , "+mouseY+" ) from"+ "(" +oldX +" , "+oldY+" )"; 
	testSVG.rotate(mouseX-oldX,mouseY-oldY);
}

/** param {number} nIterations - an integer
* param {number} B0 - 
* param {number} R
* param {number} BA
* param {vector} vecAD - for the moment, a constant value
* find the correct coordinates for A, based on B0 and R and BD.
*/

function solveB5(nIterations, B0,R,BD,vecAD)
{
	var infoText = "";
	var BA = BD; // intial estimate for BA
	var vecB5=new vector ([0,0,-B0]);
	for (var i = 0; i<nIterations ; i++)
	{
		infoText += "iteration = "+ i+"<br>";
		var vecA = find_vecA(B0,R,BA);	
		var vecD = vecA.plus(vecAD); // this will be more complicated function later
		// set new BA for better approximation
		BA = estimate_BA(BD,vecB5,vecA,vecD);

		infoText += "A : "+ vecA.toString()+"<br>";
		infoText += "D: "+vecD.toString()+" <br>";

		infoText += "BA: "+BA+" <hr>";
	}
	return { text: infoText,
		 vecA: vecA, vecD:vecD
		};
}

/** sketch:
   A   D

     O                  B
* the vector from A to D is fixed (horizontal, of fixed length)).
* O and B are fixed points.
* known distances:
* BD is known
* OA is known
* The distance AB is be calculated by an iterative process
*/




var displayText = "";

var vectorA = new vector([0,10,3]);
var vectorD = new vector([0,10,0]);
var vectorAD = vectorD.minus(vectorA);

testSVG.addSegment([20,40,0],[80,50,40],"#00F");
testSVG.addSegment(vectorA.vector,vectorD.vector);
			       /// why is this invisible ????????????????

var B0 = 15; // fixed position between B5 and the axis
var vectorB5 = new vector ([0,0,-B0]);//  polar_vector(B0,Math.PI/2,Math.PI/2);
var R = vectorA.norm();// // to be calculated from the triangle B1 B2
var BD = vectorB5.minus(vectorD).norm(); // to be calculated from the position of A
var BA = vectorB5.minus(vectorA).norm(); // solution
displayText += "coordinates: <br>";
displayText += "A is: "+vectorA.toString()+" <br>";
displayText += "B5: "+vectorB5.toString()+" <br>";
displayText += "D: "+vectorD.toString()+" <br>";
displayText += "solution for BA = "+ BA +"<br>";
displayText += "solution for BD = "+ BD +"<br>";

BA = BD;// -vecAD.norm(); // to be calculated from the position of A
displayText += "We will start the iteration with BA = "+ BA +"<hr>";

displayText += solveB5(20, B0,R,BD,vectorAD).text;

document.getElementById("text_out").innerHTML = displayText;

/* m.b.t. de plaatjes, draaien etc:
- op het svg-element moeten events geregistreerd worden:
	- in status "normal": onMouseDown: set state="rotate"
	- in status "rotate: onMouseMove: change pictures
		onMouseUp: set state="normal"
		onMouseOut: set state="normal"
- rotation:
	the "d" attribute of each path element must be updated.
	The program must have an array that contains for each path:
	- the id attribute (e.g. id = "vecA", "axis_x")
	- the start coordinates
	- the end coordinates
	so the "d" attribute can be calculated.

	The projection from 3D to 2D is a parallel projection.
	So essentially, just the x and y coordinates,
	after the rotation has been performed.
	
	Rotations are the product of small rotations along y-axis (phi) 
	and x-axis (theta).
	The resulting rotation matrix is stored, and when state=="rotate"
	this matrix is updated every time when the mouse is moved.
*/
</script>

</body>
</html>

</script>
