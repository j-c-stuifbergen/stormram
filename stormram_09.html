<html><!DOCTYPE html>
<link rel="stylesheet" type="text/css" href="./index.css" /> 
<body>

<h2>Stormram</h2>
One of my friends has done research on medical robots that could position a needle.
(<em> Vincent Groenhuis PhD: Robotic systems for breast biopsy
using MRI and ultrasound imaging, ISBN: 978-90-365-4892-2</em> <br>
In one of the models, called "Stormram 1", the position of the needle depends on the lengths of 5 pistons, stemming from points B1 till B5.<br>
<img src="stormram fig 7.3.png" /><br>

In his thesis (to obtain his PhD), he hints at a method to calculate the positions of A and C.<br>
<img src="stormram fig 6.7.png" /><br>
I took up the challenge to work this calculation out, and test its convergence. That could save the purchase of a Matlab licence!<br>

<p id="pict_out">
<svg id="3Dscreen" width="400" height="400" viewbox="-80 -50 130 150" onmousedown='alert("No function is activated by clicking the mouse.")'>
</svg>
</p>
<p id="message" note="for error messages etc">(click on the picture to rotate it)</p><hr>
<p>
<p>
The idea is: <br>
if we know the distance B5-A, we can calculate the position of A.<br>
<!--svg id="explain_A" width="400" height="400" viewbox="-80 -50 130 150" onmousedown='alert("No function is activated by clicking the mouse.")'-->
</svg>
We know the distance A-C, so then we can calculate the position of C.<br>
B is between A and C, and D is below B at a fixed distance (at least in my simulation. In reality, small deviations should occur, but this is not important for the convergence).
<p>
The distance B5-A depends on:<br>
- the distance B5-D (which we know)<br>
- the distance A-D (which we know)<br>
- the angles of the triangle with corners A, D, B5.<p>
These corners depend on:<br>
- the positions of C (and B and D), which depend on the position of A<br>
- the distance B5-A<p>


The solution will be to make a guess for B5-A, and then:<br>
- then calculate A
- then calculate C (and B and D)<br>
- calculate the angles of the triangle A,D,B5<br>
- then calculate B5-A<br>
- repeat...<br>
This sounds like an vicious circle.<p>

Actually, it is not a circle but a spiral: after each round, I will be nearer to the solution (in mathematical terms: the calculations <em>converge</em> to the solution).<br>
The reason is that:<br>
- a change in B5-A causes a smaller change in the angles<br>
- a change in the angles causes a smaller change in the distances B5-A<br>
So in each round, the solution will change a bit, but it will change less at each round.<br>
And when the calculations don't change in the first 3 digits after the comma, I consider the solution ready.<p>
 
<em>estimation of B5-A</em><p>
This is rather straightforward:<br>
<em> I should add a picture here...</em><br>
I estimate the position of A, and use the distances between B5 and my estimates (of A and D) to estimate the cosine of angle A-B5-D, and of angle B5-A-D.<br>
Then I estimate the distance B5-A by<br>
B5-A = B5D x cos("A-B5-D") + AD x cos("B5-A-D")
</p>
<h3>Parameters</h3>
<p id="parameters"></p>
<h3>Precision of the results</h3>
<p id="precision"></p>
<h3>Results</h3>
<p id="text_out"></p>

<script type="text/javascript" src="js/MatrixUtil2.js"></script>
<script type="text/javascript" src="js/VectorUtil.js"></script>
<script type="text/javascript" src="js/Error.js"></script>
<script>

/** sketch:
   A   D             C
       B

     B3              B1    B5
 
* the distance from A to D is fixed).
* B1 till B5 are fixed points.
* D is between A and C
* B is always under D
* known fixed distances: AD, AC, DB (and thus AC, AB)
* known distances (chosen settings):
* B-B5, B3-A, B4-A, B1-C, B2-C, B5-B, 
* The distance AB5 is calculated by an iterative process
* and adjusted till it is in agreement with the 5 set distances
*/

/* coordinates
*/
var L1 = 97.48*0.5;
var L2 = 45;
var BD = 10; 
var AB = 10;
var AC = 45; // distance between A and C

// fixed coordinates:
var b1 = new vector([L1, 0,0]);
var b2 = new vector([-L1, 0,0]);
var b3 = new vector([L1, 0,L2]);
var b4 = new vector([-L1, 0,L2]);
var b5 = new vector([0,-9.08, -22.5]);

var svgNameSpace = "http://www.w3.org/2000/svg";

function vector(coordinates)
{
	this.vector = coordinates;
	this.norm= function()
	{  	let sum = 0;
		for (let i = 0; i<this.vector.length; i++)
		{ 	sum += this.vector[i]*this.vector[i];
		}
		return Math.sqrt(sum);
	};

	this.plus = function(vec_b)
	{	let result = Array(this.vector.length);
		for (let i = 0; i<this.vector.length; i++)
		{ 	result[i]= this.vector[i] +vec_b.vector[i];
		}
		return new vector(result);
	}
	this.minus = function(vec_b)
	{	let result = Array(this.vector.length);
		for (let i = 0; i<this.vector.length; i++)
		{ 	result[i]= this.vector[i] -vec_b.vector[i];
		}
		return new vector(result);
	}
	this.times = function(scalar)
	{	let result = Array(this.vector.length);
		for (let i = 0; i<this.vector.length; i++)
		{ 	result[i]= this.vector[i] * scalar;
		}
		return new vector(result);
	}
	this.ip= function(vec_b)
	{  	let sum = 0;
		for (let i = 0; i<this.vector.length; i++)
		{ 	sum += this.vector[i]*vec_b.vector[i];
		}
		return sum;
	};
	this.unit = function()
	{	return this.times(1/this.norm());
	}

	// outer product
	this.op= function(vec_b)
	{	let coords = [];
		coords[0] = this.vector[1]*vec_b.vector[2]-this.vector[2]*vec_b.vector[1];
		coords[1] = this.vector[2]*vec_b.vector[0]-this.vector[0]*vec_b.vector[2];
		coords[2] = this.vector[0]*vec_b.vector[1]-this.vector[1]*vec_b.vector[0];
		return new vector(coords);
	}
	this.along= function (vec_b)
	{	return this.ip(vec_b)/vec_b.norm();
	}
	this.projectOn= function(vec_b)
	{  	let ip = this.ip(vec_b);
		let norm2 = vec_b.ip(vec_b);
		return vec_b.times(ip/norm2);
	}
	this.cos= function(vec_b)
	{	let ip = this.ip(vec_b);
		return ip / (this.norm()*vec_b.norm());
	}
	this.phi= function(vec_b)
	{	return Math.acos(this.cos(vec_b));	
	}
	this.toString = function()
	{	return VectorUtil.AsString(this.vector);
	}
}
function polar_vectorbycos(r,cosTheta,sinTheta, cosPhi, sinPhi)
{
	return new vector([sinTheta*cosPhi*r, sinTheta*sinPhi*r, cosTheta*r]);
}
function polar_vector(r,theta,phi)
{
	return polar_vectorbycos(r,Math.cos(theta),Math.sin(theta),Math.cos(phi),Math.sin(phi));
}
/** @param {number} a - side of a triangle
* @param {number} b - side of a triangle
* @param {number} opposite - third side of a triangle
* returns the cosine of the angle between sides a and b of a triangle
*/
function cosine(opposite,a,b)
{
	result = (-Math.pow(opposite,2)+Math.pow(a,2)+Math.pow(b,2))/(2*a*b)
	if ( result < -1 ) // a+b < opposite
	{	let tooBig = true;
		throw new CosineError("Can't create a triangle with sides of lengths "+opposite+" , "+a+" , "+b,tooBig)
	}
	if ( 1 < result)
	{	let tooBig = false;
		throw new CosineError("Can't create a triangle with sides of lengths "+opposite+" , "+a+" , "+b,tooBig)
	}

	return result;
}

/* find a better estimate for BA, given estimates for vecA and vecD,
	satisfying given values for vecB5 and B5D
	by comparing the length of vecctor from B5 to D
	with B5D.
*/
function estimate_BA(B5D,vecB5,vecA,vecD)
{
		vecAB = vecB5.minus(vecA);
		// vecABunit = vecAB.times(1/vecAB.norm());
	        vecDB = vecB5.minus(vecD);
		vecAD = vecD.minus(vecA);
		
		/* return the sum:
		 * length of DB projecte AB +
		 * the projected length that B5D should have along AB
		*/
		// if B5D == vecDB.norm(), the solution is stable
		return 	(vecAB.ip(vecAD) + 
			 vecAB.ip(vecDB) /vecDB.norm() * B5D
			)/vecAB.norm();
}

/* return a vector vecR such that:
* - vecR.norm() == R
* - || vecR - vecBasis || == BA
* - the outer product: vecR x vecBasis is parallel to vecAxis
*   so (vecR x vecBasis) x vecAxis = 0 
* - the result is a kind of right-handed system of vectors,
*   so (vecR x vecBasis) . vecAxis >= 0 
*/
function find_vec(vecAx, vecBasis,H, D, D_alongAxis, labelBasis, labelAdjacent, labelH)
{	
	D2 = 	D*D - Math.pow(D_alongAxis,2)
	if ( D2 <0 )
	{	message ="component "+labelAdjacent+" is too short to create a triangle "+labelAdjacent+" - "+labelBasis+" - "+labelH
		alert(message)
		throw new Error(message)
	}
	D_ortho = Math.sqrt(D2);
	
	var BNorm = vecBasis.norm();
	var unitBasis = vecBasis.times(1/BNorm);
	// var unitAx = vecAx.times(1/vecAx.norm());
	var unitOrtho = vecBasis.op(vecAx).unit(); // unit vector orthogonal to vecBasis and vecAx
	// var unitOrtho = vecOrtho.times(1/vecOrtho.norm());

	try
	{	var cosAxis = cosine(D_ortho,BNorm,H);
	}
	catch (exception)
	{
	  	handleCosineError(exception,labelBasis, "component of "+labelAdjacent, labelH, D_ortho, BNorm, H)
	}
	var sinAxis = Math.sqrt(1-cosAxis*cosAxis);

	var result =  unitBasis.times(cosAxis*H).plus(unitOrtho.times(sinAxis*H));
	
 	//	alert ("<br>0<B0+R-BA = ??"+"<br>cosine is cosBA = "+cosAxis+"<br>BNorm = "+BNorm+"<br>D = "+D+"<br>D = "+D+"<br>D_ortho is "+D_ortho+D+"<br>H is "+H+"<br>unitBAsis is "+unitBasis.toString()+"<br>unitOrtho is "+unitOrtho.toString()+"<br>Result is "+result.toString()); // +"<br>A is "+result.plus(vecAx).toString());
	return result;
}
function find_vecA_old(vecAx, vecBasis,R,BA)
{
	var B0 = vecBasis.norm();
	var unitBasis = vecBasis.times(1/B0);
	// var unitAx = vecAx.times(1/vecAx.norm());
	var unitOrtho = vecBasis.op(vecAx).unit(); // unit vector orthogonal to vecBasis and vecAx
	// var unitOrtho = vecOrtho.times(1/vecOrtho.norm());

	var cosBA = cosine(BA,B0,R);
	var sinBA = Math.sqrt(1-cosBA*cosBA);

	var result =  unitBasis.times(cosBA*R).plus(unitOrtho.times(sinBA*R));
	
 	// alert ("<br>0<B0+R-BA = "+(B0+R-BA)+"<br>cosine is cosBA = "+cosBA+"<br>B0 = "+B0+"<br>BA = "+BA+"<br>R = "+R+"<br>unitAx is "+unitAx.toString()+"<br>unitBAsis is "+unitBasis.toString()+"<br>unitOrtho is "+unitOrtho.toString()+"<br>Result is "+result.toString()); // +"<br>A is "+result.plus(vecAx).toString());
	return result;
}

/* perform repeated small rotation around x and z axis
*/
function Matrix_rotate(M_in,nPhi,nTheta)
{
	var N = 20; // 20 small rotations along 2 different axes
	
	var delta = 0.02 ;// standard angle of rotation, in radians
	deltaPhi = delta * nPhi/N;
	deltaTheta = - delta * nTheta/N; // negative, because y-coordinates are mirrored in svg
	cosP = Math.cos(deltaPhi);
	sinP = Math.sin(deltaPhi);
	cosT = Math.cos(deltaTheta);
	sinT = Math.sin(deltaTheta);

	// the generators of the rotations
	// = matrices for small rotations
	// theta: rotate along z axis 
	M_theta = [ [ cosT, sinT  , 0],
		    [ -sinT , cosT  , 0],
		    [     0,   0   , 1] ];
	// phi: rotate along y axis
	M_phi = [ [ cosP, 0, sinP],
		  [ 0,    1,   0 ],
		  [ -sinP,0, cosP] ];
   	M_combined = MatrixUtil.Multiply(M_theta,M_phi); 
	// displayText += "Mcombined is "+MatrixUtil.AsHMTL(M_combined);
	// for small values of delta, M_theta x M_phi = M_phi x M_theta
	var M = M_in
	for (let k =0; k<N; k++)
	{
		M = MatrixUtil.Multiply(M_combined,M);
	}
	// make the rows orthonormal, because
        // after many rotations, round-off errors may have accumulated
	for(var i = 0; i<M.length; i++)
        {
               for (var j = 0; j<i; j++)
               { 
                        M[i]=VectorUtil.Subtract(M[i],
                               VectorUtil.TimesScalar(M[j],
                                 VectorUtil.InnerProduct(M[i],M[j])));
               }
        }
	return M;
}

/** param {svgObject} svg - a reference tot the svgObject 
 * param {array} from - x,y,z
 * param { array} to - x, y , z
 */

function lineSegment(svgObject,from,to, color)
   {
   	this.from = from; // [x,y,z]
   	this.to = to; // [x,y,z]

	this.element = document.createElementNS(svgNameSpace, 'path'); //Create a path in SVG's namespace
	this.element.style.stroke = color; //Set stroke colour
	this.element.style.strokeWidth = "2px"; //Set stroke width
	
   	this.setAtrb=function(attribute,value)
	   {	this.element.setAttributeNS(null,attribute,value);
	   }
   	/** @params {array} M_rotation - 3 x 3 matrix
   	*   @params {array} center - 	the center of the rotation, and of the projection
   	*/

   	this.project = function(M_rotation,center)
   	{	var from = VectorUtil.Subtract(this.from,center);
			from =MatrixUtil.TimesVector(M_rotation,from);
   		var to = VectorUtil.Subtract(this.to,center);
   			to = MatrixUtil.TimesVector(M_rotation,to);
		var pathDef = "M "+from[0]+" "+from[1]+" "+to[0]+" "+to[1]+" ";
		this.element.setAttribute("d",pathDef); //Set path's data
	}
   }
/** param {svgObject} svg - a reference tot the svgObject 
 * param {array} from - x,y,z
 * param { array} to - x, y , z
 */

function svgText(svgObject,coordinates,text, color)
   {
	this.element = document.createElementNS(svgNameSpace, 'text'); //Create a text in SVG's namespace

   	this.setAtrb=function(attribute,value)
	   {	this.element.setAttributeNS(null,attribute,value);
	   }

   	this.coord = coordinates; // [x,y,z]

	this.element.style.stroke = color; //Set stroke colour
	this.element.style.strokeWidth = "0.3px"; //Set stroke width
	this.element.textContent = text;
	this.setAtrb("font-family","sans-serif")
	this.setAtrb("font-size",5)
	this.setAtrb("x",coordinates[0])
	this.setAtrb("y",coordinates[1])
	
	this.setText= function(text)
	{	this.element.textContent = text;
	}

   	/** @params {array} M_rotation - 3 x 3 matrix
   	*   @params {array} center - 	the center of the rotation, and of the projection
   	*/

   	this.project = function(M_rotation,center)
   	{	var coord = VectorUtil.Subtract(this.coord,center);
			coord =MatrixUtil.TimesVector(M_rotation,coord);
   		this.setAtrb("x",coord[0])
   		this.setAtrb("y",coord[1])
	}
   }

function svgObjects(svgId)
{
	// private variables
	var svg = document.getElementById(svgId); //Get svg element
	var Mat_orient =	[ [-1,  0  , 0],
		[   0, 1  , 0],
		[   0,   0   , -1] ];  
	var Mat_projection_init =	[ [ 0,  0  , 1],
		[   0, -1  , 0],
		[   0,   0   , 0] ];

	var Mat_projection = MatrixUtil.Multiply(Mat_projection_init,Mat_orient);

	this.svg = function ()
	{	return svg;
	}
	// because positive y is down on the screen
	var that = this; 

	center = [20,20,20]

	this.setCenter=function(xyz)
		{       if (3 == xyz.length)
		        {       center = xyz;
		        }
		}
        this.elements = []; // array of lineSegments

	this.addCircle = function(center, color)
        {};
        
        this.addSegment = function (from,to,color)
	{
		let count = this.elements.length;
		this.elements[count] = new lineSegment(that,from,to,color);
		svg.appendChild(this.elements[count].element);
		this.elements[count].project(Mat_projection,center);
                return this.elements[count]; // return a handle to the segment
	}
	this.addText = function (coord,text,color)
	{
		let count = this.elements.length;
		this.elements[count] = new svgText(that,coord,text,color);
		svg.appendChild(this.elements[count].element);
		this.elements[count].project(Mat_projection,center);
                return this.elements[count]; // return a handle to the segment
	}
	this.rotate = function(down,right)
	{
		Mat_orient = Matrix_rotate(Mat_orient, down,right);
                Mat_projection = MatrixUtil.Multiply(Mat_projection_init,Mat_orient);
   		this.project();
	}

	this.project = function()
	{
   		for( let i = 0; i<this.elements.length; i++)
   		{
		this.elements[i].project(Mat_projection,center);
   		}
	}

}
axisSVG = new svgObjects("3Dscreen");
{	let axisColor = "#933";
	let axL = 15;
	let labelDist = 15;

	let originShift = new vector([-20,0,80])
	let origin = new vector([0,0,0]).plus(originShift)
	let xAxis = new vector([axL,0,0]).plus(originShift)
	let yAxis = new vector([0,axL,0]).plus(originShift)
	let zAxis = new vector([0,0,axL]).plus(originShift)

	axisSVG.addSegment(origin.vector,xAxis.vector,axisColor)
	axisSVG.addSegment(origin.vector,yAxis.vector,axisColor)
	axisSVG.addSegment(origin.vector,zAxis.vector,axisColor)

	let xAxisLabelCoord = new vector([labelDist,0,0]).plus(originShift)
	let yAxisLabelCoord = new vector([0,labelDist,0]).plus(originShift)
	let zAxisLabelCoord = new vector([0,0,labelDist]).plus(originShift)

	axisSVG.addText(xAxisLabelCoord.vector,"X",axisColor)
	axisSVG.addText(yAxisLabelCoord.vector,"Y",axisColor)
	axisSVG.addText(zAxisLabelCoord.vector,"Z",axisColor)
	
}

resultSvg = new svgObjects("3Dscreen");
resultSvg.setCenter([15,20,30]); 
resultSvg.rotate(8,5);
axisSVG.rotate(8,5);
var mouseX, mouseY;


svg = resultSvg.svg();
   svg.setAttributeNS(null,'onmousedown',"mouseIsDown(evt)");
   svg.setAttributeNS(null,'onmouseup',"mouseIsUp(evt)");
function mouseIsDown(e)
{	
  	takeCoordinates(e)
	svg.setAttributeNS(null,'onmousemove',"mouseHasMoved(evt)");
}
function takeCoordinates(e)
{
	mouseX =   e.clientX||e.changedTouches[0].clientX;
	mouseY =   e.clientY||e.changedTouches[0].clientY;
}
function mouseIsUp(e)
{
   svg.setAttributeNS(null,'onmousemove',null);
}
function mouseHasMoved(e)
{
	oldX= mouseX;
	oldY= mouseY;
	takeCoordinates(e)
	resultSvg.rotate(mouseX-oldX,mouseY-oldY);
	axisSVG.rotate(mouseX-oldX,mouseY-oldY);
}

/** param {number} nIterations - an integer
* param {number} B0 - distance from B5 to the axis B1-B2 (roughly under A)
* param {number} R - initial guess for AD
* param {number} BA - initial guess for BA
* param {vector} vecAD - for the moment, a constant value
* find the correct coordinates for A, based on B0 and R and B5D.
*/

function solveB5(params)
{
	var nIterations = params.nIterations;
	var R1 = params.R1;
	var R2 = params.R2;
	var R3 = params.R3;
	var R4 = params.R4;
	var B5D = params.B5D;
	var AB = params.AB;
	var AC = params.AC;
	var vecBD = params.vecBD ;

	var vecA;
	var infoText = "<hr>";

	var B5toA = B5D; // intial estimate for BA, e.g. BA =B5D
	settingText = "Settings: "
	settingText += "<br>R1 = "+R1;
	settingText += "<br>R2 = "+R2;
	settingText += "<br>R3 = "+R3;
	settingText += "<br>R4 = "+R4;
	settingText += "<br>R5 = "+B5D;
	settingText += "<br>fixed distances :";
	settingText += "<br>AC = "+AC;
	settingText += "<br>AB = "+AB;
	settingText += "<br>BD = "+vecBD.norm();
	settingText += "<br>fixed positions :";
	settingText += "<br>b1 = "+b1;
	settingText += "<br>b2 = "+b2;
	settingText += "<br>b3 = "+b3;
	settingText += "<br>b4 = "+b4;
	settingText += "<br>b5 = "+b5;
	settingText += "<hr>";

	infoText += "We will start the iteration with B5toA = "+ B5toA +"<br>";
	var vectorAxis = b4.minus(b3); // b4.minus(b3) gives the wrong orientation

	// var triangleInfo_A = axisPoint(vectorAxis, R3,R4);// Axis points from b3 to b4
	var triangleInfo_A = footOnAxis(b3,b4, R3,R4, "B5-D", "R3","R4");// the foot of A on the axis
	var foot_A = triangleInfo_A.landingVec.plus(b3);
	var B5_projected = b5.minus(foot_A).projectOn(vectorAxis)
	let basisVec = b5.minus(foot_A).minus(B5_projected) // b5+(vecC-b5)pO(axis)-veC
	
	var vectorAxis_C = b1.minus(b2); // b2.minus(b3) gives the wrong orientation in find_vec
	//	var triangleInfo_C = axisPoint(vectorAxis_C, R1,R2);// Axis points from b1 to b2
	var triangleInfo_C = footOnAxis(b1,b2, R1,R2,"A-C","R1","R2");// Axis points from b1 to b2
	var foot_C = triangleInfo_C.landingVec.plus(b1);
	var hC = triangleInfo_C.H;

	// By definition of b1 and b2, foot_C has y=0 and z=0
	
	infoText += "H : "+triangleInfo_A.H+"<br>";	
	infoText += "||A|| according to triangle: "+Math.sqrt(Math.pow(triangleInfo_A.H,2)+Math.pow(triangleInfo_A.landingVec.norm(),2))+"<br>";
		infoText += "vectorAxis is : "+ vectorAxis.toString()+"<br>";
		infoText += "b5 is : "+ b5.toString()+"<br>";
		infoText += "b5 projected is : "+ B5_projected.toString()+"<br>";
		infoText += "basisVec is : "+ basisVec.toString()+"<br>";
		infoText += "B5 axial is : "+ B5_projected.norm()+"<br>";
		infoText += " Basis_vec must be ortho to axis: ip = "+basisVec.ip(vectorAxis)+"<br>";
		infoText += "foot_A is : "+ foot_A.toString()+"<br>";
		infoText += "foot_A-b5 is : "+ foot_A.minus(b5).toString()+"<br>";
	infoText += "vectorAxis_C is : "+ vectorAxis_C.toString()+"<br>";
	infoText += "R1 is : "+ R1+"<br>";
	infoText += "R2 is : "+ R2+"<br>";
	infoText += "foot_C is : "+ foot_C.toString()+"<br>";
	infoText += "hC is : "+ hC+"<br>";
	/**/

	for (var i = 0; i<nIterations ; i++)
	{
		infoText += "<hr>iteration = "+ i+"<br>";
		infoText += "B5toA: "+B5toA+" <br>";

		// estimate A
		vecA = find_vec(vectorAxis,basisVec,triangleInfo_A.H,B5toA,B5_projected.norm(), "A","B to A","H of A").plus(foot_A);	

		// calculate C
		let A_projected = vecA.minus(foot_C).projectOn(vectorAxis_C)
		let basisVec_A = vecA.minus(foot_C).minus(A_projected) // from A to the axis of C

		infoText += "<b>input for vecC</b> ";
		infoText += "<br> vectorAxis_C = "+vectorAxis_C
		infoText += "<br> basisVec_A = "+basisVec_A
		infoText += "<br> hC = "+triangleInfo_C.H
		infoText += "<br> AC = "+AC
		infoText += "<br> A along axisC = "+A_projected.norm() 
		infoText += "<br> foot_C = "+foot_C+"<br>"

		var vecC = find_vec(vectorAxis_C,basisVec_A,triangleInfo_C.H,AC,A_projected.norm(), "C", "AC", " hC ").plus(foot_C);	
		// calculate B, between A and C
		var vecB = vecA.times(1-AB/AC).plus(vecC.times(AB/AC));
		// estimate D		
		var vecD = vecB.plus(vecBD); // not correct - this will be a more complicated function, setting the J14 axis parallel to J13

		// set a better value for BA for the nex approximation
		B5toA = estimate_BA(B5D,b5,vecA,vecD);

		// alternative calculation of C, to test find_vec
		// C is at the intersection of the sphere around A of radius AC
		// with the circle orthogonal to the axis (b1-->b2) with radius hC
		// and center foot_C
		// So
		// (x-xA)^2 + (y-yA)^2 +(z-zA) = R^2
		// and, because b1 and b2 are on the x axis,
		// x is given by and foot_C and 
		// y^2 + z^2 = H^2
		dX = foot_C.vector[0] - vecA.vector[0];
		yA = vecA.vector[1]; zA =vecA.vector[2]
		K = 0.5 * (hC*hC + dX*dX + yA*yA + zA*zA - AC*AC);
		yC = quadraticRoot(K*K-zA*zA*hC*hC, -2*K*yA, yA*yA+zA*zA)[1] // take the highest y-value

		// !!! z = Math.sqrt(hC*hC -yC*yC)]) // wrong because this will not yield a negative value for z.
		// z= zA-sqrt(R^2-(yC-yA)^2-dX^2)
		var z = zA-Math.sqrt(AC*AC - (yC-yA)*(yC-yA) - dX*dX); // for the solution with z < zA
		// var vecC = new vector([foot_C.vector[0], yC, Math.sqrt(hC*hC -yC*yC)])
		var vecC_alternative = new vector([foot_C.vector[0], yC, z])


		var vecC_check = vecC_alternative.minus(vecC)		
		// infoText += "Controle : sqrt(R^2 -y^2 - z^2) ="+ Math.sqrt(AC*AC- (yC-yA)*(yC-yA) - Math.pow(z-zA,2))+"<br>";

		infoText += "A : "+ vecA.toString()+"<br>";
		infoText += "C : "+ vecC.toString()+"<br>";
		infoText += "C alt : "+ vecC_alternative.toString()+"<br>";
		infoText += "C check : "+ vecC_check.toString()+"<br>";
		infoText += "B : "+ vecB.toString()+"<br>";
		infoText += "D: "+vecD.toString()+" <br>";

	}

	// perform checks
	var checkText = "";
	var prec = 5; // precision for displaying numbers
	var error2Sum = 0;
	// R1, R2, R3, R4, R5=B5D
	let err = b1.minus(vecC).norm()-R1; error2Sum += err*err;
	checkText += "from B1 to C :"+b1.minus(vecC).norm().toFixed(prec)+" - "+R1.toFixed(prec) +" = "+err;
	err = b2.minus(vecC).norm()-R2; error2Sum += err*err;
	checkText += "<br>from B2 to C :"+b2.minus(vecC).norm().toFixed(prec)+" - "+R2.toFixed(prec) +" = "+err;
	err = b3.minus(vecA).norm()-R3; error2Sum += err*err;
	checkText += "<br>from B3 to A :"+b3.minus(vecA).norm().toFixed(prec)+" - "+R3.toFixed(prec) +" = "+err;
	err = b4.minus(vecA).norm()-R4; error2Sum += err*err;
	checkText += "<br>from B4 to A :"+b4.minus(vecA).norm().toFixed(prec)+" - "+R4.toFixed(prec) +" = "+err;
	err = b5.minus(vecD).norm()-B5D; error2Sum += err*err;
	checkText += "<br>from B5 to D :"+b5.minus(vecD).norm().toFixed(prec)+" - "+B5D.toFixed(prec) +" = "+err;
	// AB, AC, BD
	err = vecB.minus(vecA).norm()-AB; error2Sum += err*err;
	checkText += "<br>from A to B :"+vecB.minus(vecA).norm().toFixed(prec)+" - "+AB.toFixed(prec) +" = "+err;
	err = vecC.minus(vecA).norm()-AC; error2Sum += err*err;
	checkText += "<br>from A to C :"+vecC.minus(vecA).norm().toFixed(prec)+" - "+AC.toFixed(prec) +" = "+err;
	err = vecB.minus(vecC).norm()-(AC-AB); error2Sum += err*err;
	checkText += "<br>from B to C :"+vecB.minus(vecC).norm().toFixed(prec)+" - "+(AC-AB).toFixed(prec) +" = "+err;
	err = vecB.minus(vecD).norm()-BD; error2Sum += err*err;
	checkText += "<br>from B to D :"+vecB.minus(vecD).norm().toFixed(prec)+" - "+BD.toFixed(prec) +" = "+err;
	err2 = Math.sqrt(error2Sum);
	checkText += "<br>sqrt(sum(error^2)):"+err2+"<hr>";
	
	// axis J5? is parallel to axis from B5
	return { vecA: vecA,
		 vecB: vecB,
		 vecC: vecC,
		 vecD:vecD,
		 err2: err2,
		 text: infoText,
		 settingText: settingText,
		 checkText: checkText
		};
}

function axisPoint(axVector, adjacentL, oppositeL)
{
	cosPhi = cosine(oppositeL, adjacentL,axVector.norm());
	B = cosPhi*adjacentL;
	R = adjacentL*(Math.sqrt(1-cosPhi*cosPhi));

	Center = axVector.times(B/axVector.norm());

	return { H: R, landingVec: Center}
}

/* param {vector} axStart
   param {vector} axEnd
   param {Number} adjacentL
   param {Number} oppositeL
   param {String} labelToSummit
   param {String} labelAdj
   param {String} labelOpp
*/    
function footOnAxis(axStart, axEnd, adjacentL, oppositeL, labelToSummit, labelAdj, labelOpp)
{
	var axVector = axEnd.minus(axStart);

	try
	{
		cosPhi = cosine(oppositeL, adjacentL,axVector.norm());
	}
	catch (exception)
	{
	  	handleCosineError(exception,"Axis for "+labelToSummit, labelAdj, labelOpp, axVector.norm(),adjacentL,oppositeL)
	/* if (exception instanceof CosineError)
		{
			if (exception.tooBig)
			{	message = "Can't construct triangle "+labelToSummit+"-"+labelAdj+"-"+labelOpp+", because "+labelOpp+" is too big compared to "+labelAdj+" ("+oppositeL+" vs "+adjacentL+"). ";
			}
			else
			{	message = "Can't construct triangle "+labelToSummit+"-"+labelAdj+"-"+labelOpp+", try a bigger value for "+labelOpp+" (currently "+oppositeL+" ). ";
			}
			//	exception.addMessage(message); throw (exception);
			throw (new Error (message + exception.message));
		}
		else 
		{	throw (exception)
		}*/
	}	
	B = cosPhi*adjacentL;
	R = adjacentL*(Math.sqrt(1-cosPhi*cosPhi));

	Center = axVector.times(B/axVector.norm());
	return { axisVec: axVector,
		 H: R,
		 landingVec: Center};
}

function handleCosineError(exception,labelAdj1, labelAdj2, labelOpp, adjacent1L, adjacent2L, oppositeL)
{
  	if (exception instanceof CosineError)
	{
		if (exception.tooBig)
		{	message = "Can't construct triangle "+labelAdj1+"-"+labelAdj2+"-"+labelOpp+", "+labelOpp+" is too big compared to "+labelAdj2+" ("+oppositeL+" vs "+adjacent2L+"). ";
		}
		else
		{	message = "Can't construct triangle "+labelAdj1+"-"+labelAdj2+"-"+labelOpp+", try a bigger value for "+labelOpp+" (currently "+oppositeL+" ). ";
		}
		//	exception.addMessage(message); throw (exception);
		alert(message+exception.message)
		throw (new Error (message + exception.message));
	}
	else 
	{	throw (exception)
	}
}

/* solve c0 + c1 y +c2 y^2 = 0 
note: will return 2 solutions in an array, 
this will be NaN if no (real) solutions are possible
*/
function quadraticRoot_old(c0,c1,c2)
{
	if (c1*c1 < 4*c0*c2)
	{ alert (" impossible root: "+[c0,c1,c2]);
	}
	var D = Math.sqrt(c1*c1 - 4*c0*c2);
	
	var result = [];
	result[0] = 0.5 * (-c1 - D)/c2;
	result[1] = 0.5 * (-c1 + D)/c2;
	return result	;
}

function quadraticRoot(c0,c1,c2)
{
	if (c1*c1 < 4*c0*c2)
	{ alert (" impossible root: "+[c0,c1,c2]);
	}
	var g = 0.5*c1/c2;

	var D = Math.sqrt(g*g - c0/c2);
	
	var result = [];
	result[0] = -g-D;
	result[1] = -g+D;
	return result	;
}

createStormram = function(svgObject, b1,b2,b3,b4,b5)
{
	labelDistance = 5; // distance from a label to a point

        pistonColor = "#00A";
	textColor = "#222";

	// unknown vectors will obtain a value in this.update

	unknown = new vector([0,0,0]);

        b1C_segment = svgObject.addSegment(b1.vector,unknown.vector,pistonColor);
        b2C_segment = svgObject.addSegment(b2.vector,unknown.vector,pistonColor);
        b3A_segment = svgObject.addSegment(b3.vector,unknown.vector,pistonColor);
        b4A_segment = svgObject.addSegment(b4.vector,unknown.vector,pistonColor);
        b5B_segment = svgObject.addSegment(b5.vector,unknown.vector,pistonColor);

	b1Letter = svgObject.addText(b1.plus(new vector( [-labelDistance,-labelDistance,0])).vector,"B1",textColor);
	b2Letter = svgObject.addText(b2.plus(new vector( [labelDistance,-labelDistance,0])).vector,"B2",textColor);
	b3Letter = svgObject.addText(b3.plus(new vector( [-labelDistance,-labelDistance,0])).vector,"B3",textColor);
	b4Letter = svgObject.addText(b4.plus(new vector( [labelDistance,-labelDistance,0])).vector,"B4",textColor);
	b5Letter = svgObject.addText(b5.plus(new vector( [0,-labelDistance,-labelDistance])).vector,"B5",textColor);

	aLabelShift = new vector( [0,labelDistance,labelDistance])
	bLabelShift = new vector( [0,labelDistance,0])
	cLabelShift = new vector( [0,labelDistance,-labelDistance])
	dLabelShift = new vector( [0,-labelDistance,0])
	
	aLetter = svgObject.addText(unknown.vector,"A",textColor);
	bLetter = svgObject.addText(unknown.vector,"B",textColor);
	cLetter = svgObject.addText(unknown.vector,"C",textColor);
	dLetter = svgObject.addText(unknown.vector,"D",textColor);

        connectionColor = "#2FF"
        AC_segment = svgObject.addSegment(unknown.vector,unknown.vector,connectionColor);
        DB_segment = svgObject.addSegment(unknown.vector,unknown.vector,"#800");

        svgObject.project();

        this.update = function(vectorA,vectorC,vectorD,vectorB)
        {
        AC_segment.from = vectorA.vector;
        DB_segment.from = vectorD.vector;
        AC_segment.to = vectorC.vector;
        DB_segment.to = vectorB.vector;

        b1C_segment.to = vectorC.vector;
        b2C_segment.to = vectorC.vector;
        b3A_segment.to = vectorA.vector;
        b4A_segment.to = vectorA.vector;
        b5B_segment.to = vectorD.vector;

	aLetter.coord = vectorA.plus(aLabelShift).vector;
	bLetter.coord = vectorB.plus(bLabelShift).vector;
	cLetter.coord = vectorC.plus(cLabelShift).vector;
	dLetter.coord = vectorD.plus(dLabelShift).vector;
        svgObject.project();
        }
}

var stormram = new createStormram(resultSvg, b1,b2,b3,b4,b5)
var displayText = "";

var configuration = { nIterations: 20,
		R1: 80,// vectorC.minus(b1).norm(), 
		R2: 80,//vectorC.minus(b2).norm(),
		R3: 76,// vectorA.minus(b3).norm(),
		R4: 66,// vectorA.minus(b4).norm(),
		B5D :85,//  B5D,
		AB : AB,
		AC : AC, // vectorA.minus(vectorC).norm()
		vecBD : new vector([0,-10,0])
};

var solution = solveB5(configuration);
var stormram = stormram.update(solution.vecA,solution.vecC,solution.vecD,solution.vecB)

document.getElementById("parameters").innerHTML =  solution.settingText;
document.getElementById("precision").innerHTML =  solution.checkText;
document.getElementById("text_out").innerHTML =  displayText+ solution.text;

/* m.b.t. de plaatjes, draaien etc:

- rotation:
The projection from 3D to 2D is a parallel projection.
So essentially, just the x and y coordinates,
after the rotation has been performed.

Rotations are the product of small rotations along y-axis (phi) 
and x-axis (theta).
The resulting rotation matrix is stored, and when state=="rotate"
this matrix is updated every time when the mouse is moved.
*/
</script>

</body>
</html>

</script>
