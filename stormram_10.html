<html>
<!DOCTYPE html>

<HEAD> 
<TITLE>stormram calculation</TITLE></HEAD>

<link rel="stylesheet" type="text/css" href="./index.css" /> 

  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<body>

<h2>Stormram</h2>
One of my friends has done research on medical robots that could position a needle.
(<em> Vincent Groenhuis PhD: Robotic systems for breast biopsy
using MRI and ultrasound imaging, ISBN: 978-90-365-4892-2</em> <br>
In one of the models, called "Stormram 1", the position of the needle depends on the lengths of 5 pistons, stemming from points B1 till \(B_5\).<br>
<img src="./pics/groenhuis fig 7.3.png" /><br>

In his thesis (to obtain his PhD), he hints at a method to calculate the positions of \(A\) and C.<br>
<img src="./pics/groenhuis fig 6.7.png" /><br>
I took up the challenge to work this calculation out, and test its convergence. That could save the purchase of a Matlab licence!<br>
Also, Vincent Groenhuis states, among possible explanations for the deviation from experiment: misalignment of points \(\vec B\) and  \(\vec D\) .
(paragraf 6.6, page 121). This happens when \(\vec D\) rotates around axis AC. Such a rotation should happen because torsion in the beam J5 (from \(B_5\) to D) should align axis J14 with axis J13 in the picture below. My model <em>calculates</em> exactly this misalignment.<br>
<img src="./pics/groenhuis fig 7.7.png" /><br>

<p id="pict_out">
<svg id="3Dscreen" width="400" height="400" viewbox="-80 -50 130 150" onmousedown='alert("No function is activated by clicking the mouse.")'>
</svg>
</p>
<p id="message" note="for error messages etc">(click on the picture to rotate it - note that the orientation of the axes is taken from fig. 6.7)</p><hr>
<p>
<p>
The idea is: <br>
if we know the distance \(B_5A\), we can calculate the position of \(\vec A\).<br>
We know the distance \(AC\), so then we can calculate the position of \(\vec C\).<br>
\(\vec B\) is between \(\vec A\) and \(\vec C\), and \(\vec D\) is at a fixed distance from \(\vec A\) and from \(\vec B\). \(\vec D\) may turn around the axis \(\vec A - \vec C\) such that \(\hat J_{14}\) is parallel to \(\hat J_{13}\). A change in \(\vec D\) has a small effect on the distance \(B_5A\).
<p>

The solution will be to make a guess for \(B_5A\), and then:<br>
- calculate \(\vec A\)<br>
- calculate \(\vec C\) (and \(\vec B\))<br>
- <em>estimate</em> \(\vec D\)<br>
- calculate the orientation of \(\hat J_{15}\)<br>
- improve our estimate for  \(\vec D\) <br>
- calculate the angles of the triangle \(\triangle ADB_5\)<br>
- improve our estimate for \(B_5A\)<br>
- repeat...<br>
This sounds like an vicious circle.<p>

Actually, it is not a circle but a spiral: after each round, I will be nearer to the solution (in mathematical terms: the calculation <em>converges</em> to the solution).<br>
The reason is that:<br>
- a change in \(B_5A\) causes a smaller change in the angles<br>
- a change in the angles causes a smaller change in the distances \(B_5A\)<br>
So in each round, the solution will change a bit, but it will change less at each round.<br>
And when the calculations don't change in the first 3 digits after the comma, I consider the solution ready.<p>
 
<hr>
<em>improving my estimate for \(B_5A\)</em><p>
<img src="./pics/pict3_improve_B5A.jpeg" height=200 /><br>

\(\vec B_5\) is fixed, and I have estimates for \(\vec A\) and \(\vec D\) (I label the estimates after \(n+1\) iterations \(\vec A_n\) and \(\vec D_n\)). From the lengths of the sides, I calculate \(cos (\beta)\) and \(cos( \gamma\)) (using the cosine rule).<br>
I know the distance \(AD\), and I know what \(B_5D\) should be. I use this value in \[(B_5A)_{n+1} = (AD)cos(\gamma_{n})+ (B_5D) cos(\beta_n)\]
Here, \( (B_5A)_n\) is my estimate for \(B_5A\) used at iteration \(n\). <br>
In the picture, this corresponds to the distance \(A_nD_{n,f} + D_{n,f}'B_5\).<br>
The angles \(\beta\) and \(\gamma\) don't change much between iterations, so this calculation provides an excellent estimate.

<p>
<em>calculation of \(\vec A\)</em><br>
<img src="./pics/pict4_find_A.jpeg" height=280/><br>
The distances to \(\vec A\) from \(\vec B_3 \) and \(\vec B_4 \) are given, the positions of \( \vec B_3 \) and \( \vec B_4 \) also.
Using the cosine rule, I can calculate \(\vec A_f\), the "foot" of \(\vec A\). (A line from the foot to \(\vec A\) is perpendicular to the axis  \(\vec B_4 - \vec B_3 \).)
Pythagoras's theorem then tells me the distance (\(h_A\), \(h\) for "height") from \(\vec A\) to \(\vec{A_f}\) .
I want to calculate an angle around the axis \(\vec B_4 - \vec B_3 \), so I create the triangle \(\triangle B_5'AA_f\) in a plane that is perpendicular to the axis. The vector from \(\vec B_5\) to \(\vec {B_5'}\) is the same as from \(\vec B_A\) to \(\vec A_f\), and equals the component of \(\vec A_f-\vec B_5\) along \( \vec B_4 - \vec B_3 \).<br>
And Pythagoras tells us that  \(B_5'A^2 = BA^2 - BB_5'^2\), so I know the lengths of all sides of \(\triangle AA_fB_5'\).<br>
<img src="./pics/pict5_find_A.jpeg"height=200 /><br>
Then I apply the cosine rule to calculate the cosine of the angle at \(\vec A_f\).
I suppose that the sine will be positive, so \( sin(\alpha_f) = \sqrt{1-cos^2(\alpha_f)}\).<br>
I measure the cosine along an unit vector \(\hat e_\parallel\), which is defined by the vector from \(\vec A_f\) to \(\vec B_5'\).<br>
For the sine, I define a unit vector \(\hat e_\perp\) that is perpendicular to this vector, but still in the plane of \(\triangle B_5'AA_f\). Therefor, I take the outer product of \(\vec A_f - \vec B_5'\) and \(\vec B_4 - \vec B_3\).<br>
Then \(\vec A = \vec{A_f} +  h_A cos(\alpha)\hat e_\parallel + h_A sin(\alpha) \hat e_\perp\) <br>
Note that I don't calculate angles with respect to an \(x\), \(y\) or \(z\) axis, but with respect to \(\vec{A_f} - \vec{B_5'}\), so \(\vec B_5\) does not have to lie in the \(xz\)-plane.
<p>
<em>calculation of \(\vec C\) </em><br>
<img src="./pics/pict6_find_C.jpeg"height=200 /><br>
This is really similar, as the drawing shows. Instead of the axis  \(\vec B_4 - \vec B_3 \), I take  \(\vec B_1 - \vec B_2 \). This ensures the correct orientation of \(\hat e_\perp\) (upward). Of course, at each iteration, the positions of \(\vec A\) and \(\vec A'\) may change.<p>
<p>
<em>calculation of \(\vec B\)</em><br>
\(\vec B\) is simply on the line between \(\vec A\) and \(\vec C\), at a fixed distance:
\(\vec B = (1-\lambda) \vec A + \lambda \vec C\) with \(\lambda = (AB/AC)\)
<!--\(\vec B = (1-{AB\over AC}) \vec A + {AB\over AC} \vec C\) -->

<P>
<em>estimation of \(\vec D\)</em><br>
For the first iteration, I suppose that \(\vec D\) is straight under \(\vec B\).<br>
At later iterations, I will use the orientation of \(\hat J_{15}\) from the previous iteration.
<p>
<em> calculation of \(\hat J_{15}\) and \(\vec D\)</em><br>
Look at picture 7.7. I calculate the axis \(\hat J_{13}\) from the outer product \( (\vec B_2 - \vec B_1) \times (\vec D -\vec B_5) \). <br>
Then  \(\hat J_{15} = \hat J_{13} \times {(\vec A - \vec C) \over (AC)}\).
And then \(\vec D - \vec B = {DB\over AB}  {(\vec A - \vec B)} \times \hat J_{15}\)<br>
This value is used to calculate \(\vec D\), and also to estimate \(\vec D\) in the next iteration.

<h3>Parameters</h3>
<p id="parameters"></p>
<h3>Precision of the results</h3>
<p id="precision"></p>
<h3>Results</h3>
<p id="text_out"></p>

<script type="text/javascript" src="js/MatrixUtil2.js"></script>
<script type="text/javascript" src="js/VectorUtil.js"></script>
<script type="text/javascript" src="js/Error.js"></script>
<script>

/** sketch:
   A   D             C
       B

     B3              B1    B5
 
* the distance from A to D is fixed).
* B1 till B5 are fixed points.
* D is between A and C
* B is always under D
* known fixed distances: AD, AC, DB (and thus AC, AB)
* known distances (chosen settings):
* B-B5, B3-A, B4-A, B1-C, B2-C, B5-B, 
* The distance AB5 is calculated by an iterative process
* and adjusted till it is in agreement with the 5 set distances
*/

/* coordinates
*/
var L1 = 97.48*0.5; // fig 6.4 of Vincent's thesis
var L2 = 45; // fig 6.4 of Vincent's thesis
var AB = 15.07; // eq. 6.10 in Vincent's thesis
var BD = AB; 
var AC = 45.833; // distance between A and C, eq. 6.10 in Vincent's thesis

// fixed coordinates: according to fig 6.4 of Vincent's thesis
var b1 = new vector([L1, 0,0]);
var b2 = new vector([-L1, 0,0]);
var b3 = new vector([L1, 0,L2]);
var b4 = new vector([-L1, 0,L2]);
var b5 = new vector([0,-9.08, -22.5]);

var svgNameSpace = "http://www.w3.org/2000/svg";

function vector(coordinates)
{
	this.copy = function()
	{	return new vector(this.vector)
	}
	this.vector = coordinates;
	this.norm= function()
	{  	let sum = 0;
		for (let i = 0; i<this.vector.length; i++)
		{ 	sum += this.vector[i]*this.vector[i];
		}
		return Math.sqrt(sum);
	};

	this.plus = function(vec_b)
	{	let result = Array(this.vector.length);
		for (let i = 0; i<this.vector.length; i++)
		{ 	result[i]= this.vector[i] +vec_b.vector[i];
		}
		return new vector(result);
	}
	this.minus = function(vec_b)
	{	let result = Array(this.vector.length);
		for (let i = 0; i<this.vector.length; i++)
		{ 	result[i]= this.vector[i] -vec_b.vector[i];
		}
		return new vector(result);
	}
	this.times = function(scalar)
	{	let result = Array(this.vector.length);
		for (let i = 0; i<this.vector.length; i++)
		{ 	result[i]= this.vector[i] * scalar;
		}
		return new vector(result);
	}
	this.ip= function(vec_b)
	{  	let sum = 0;
		for (let i = 0; i<this.vector.length; i++)
		{ 	sum += this.vector[i]*vec_b.vector[i];
		}
		return sum;
	};
	this.unit = function()
	{	return this.times(1/this.norm());
	}

	// outer product
	this.op= function(vec_b)
	{	let coords = [];
		coords[0] = this.vector[1]*vec_b.vector[2]-this.vector[2]*vec_b.vector[1];
		coords[1] = this.vector[2]*vec_b.vector[0]-this.vector[0]*vec_b.vector[2];
		coords[2] = this.vector[0]*vec_b.vector[1]-this.vector[1]*vec_b.vector[0];
		return new vector(coords);
	}
	this.along= function (vec_b)
	{	return this.ip(vec_b)/vec_b.norm();
	}
	this.projectOn= function(vec_b)
	{  	let ip = this.ip(vec_b);
		let norm2 = vec_b.ip(vec_b);
		return vec_b.times(ip/norm2);
	}
	this.cos= function(vec_b)
	{	let ip = this.ip(vec_b);
		return ip / (this.norm()*vec_b.norm());
	}
	this.phi= function(vec_b)
	{	return Math.acos(this.cos(vec_b));	
	}
	this.toString = function()
	{	return VectorUtil.AsString(this.vector);
	}
	this.toString = function(precision)
	{	return VectorUtil.AsString(this.vector,precision);
	}
}
function polar_vectorbycos(r,cosTheta,sinTheta, cosPhi, sinPhi)
{
	return new vector([sinTheta*cosPhi*r, sinTheta*sinPhi*r, cosTheta*r]);
}
function polar_vector(r,theta,phi)
{
	return polar_vectorbycos(r,Math.cos(theta),Math.sin(theta),Math.cos(phi),Math.sin(phi));
}
/** @param {number} a - side of a triangle
* @param {number} b - side of a triangle
* @param {number} opposite - third side of a triangle
* returns the cosine of the angle between sides a and b of a triangle
*/
function cosine(opposite,a,b)
{
	result = (-Math.pow(opposite,2)+Math.pow(a,2)+Math.pow(b,2))/(2*a*b)
	if ( result < -1 ) // a+b < opposite
	{	let tooBig = true;
		throw new CosineError("Can't create a triangle with sides of lengths "+opposite+" , "+a+" , "+b,tooBig)
	}
	if ( 1 < result)
	{	let tooBig = false;
		throw new CosineError("Can't create a triangle with sides of lengths "+opposite+" , "+a+" , "+b,tooBig)
	}

	return result;
}

/* find a better estimate for BA, given estimates for vecA and vecD,
	satisfying given values for vecB5 and B5D
	by comparing the length of vecctor from B5 to D
	with B5D.
*/
function estimate_BA(B5D,vecB5,vecA,vecD)
{
		vecAB = vecB5.minus(vecA);
		// vecABunit = vecAB.times(1/vecAB.norm());
	        vecDB = vecB5.minus(vecD);
		vecAD = vecD.minus(vecA);
		
		/* return the sum:
		 * length of DB projected on AB +
		 * the projected length that B5D should have along AB
		*/
		// if B5D == vecDB.norm(), the solution is stable
		return 	(vecAB.ip(vecAD) + 
			 vecAB.ip(vecDB) /vecDB.norm() * B5D
			)/vecAB.norm();
}

/* return a vector vecR such that:
* - vecR.norm() == R
* - || vecR - vecBasis || == BA
* - the outer product: vecR x vecBasis is parallel to vecAxis
*   so (vecR x vecBasis) x vecAxis = 0 
* - the result is a kind of right-handed system of vectors,
*   so (vecR x vecBasis) . vecAxis >= 0 
*/
function find_vec(vecAx, vecBasis,H, D, D_alongAxis, labelBasis, labelAdjacent, labelH)
{	
	D2 = 	D*D - Math.pow(D_alongAxis,2)
	if ( D2 <0 )
	{	message ="component "+labelAdjacent+" is too short to create a triangle "+labelAdjacent+" - "+labelBasis+" - "+labelH
		alert(message)
		throw new Error(message)
	}
	D_ortho = Math.sqrt(D2);
	
	var BNorm = vecBasis.norm();
	var unitBasis = vecBasis.times(1/BNorm);
	// var unitAx = vecAx.times(1/vecAx.norm());
	var unitOrtho = vecBasis.op(vecAx).unit(); // unit vector orthogonal to vecBasis and vecAx
	// var unitOrtho = vecOrtho.times(1/vecOrtho.norm());

	try
	{	var cosAxis = cosine(D_ortho,BNorm,H);
	}
	catch (exception)
	{
	  	handleCosineError(exception,labelBasis, "component of "+labelAdjacent, labelH, D_ortho, BNorm, H)
	}
	var sinAxis = Math.sqrt(1-cosAxis*cosAxis);

	var result =  unitBasis.times(cosAxis*H).plus(unitOrtho.times(sinAxis*H));
	
 	//	alert ("<br>0<B0+R-BA = ??"+"<br>cosine is cosBA = "+cosAxis+"<br>BNorm = "+BNorm+"<br>D = "+D+"<br>D = "+D+"<br>D_ortho is "+D_ortho+D+"<br>H is "+H+"<br>unitBAsis is "+unitBasis.toString()+"<br>unitOrtho is "+unitOrtho.toString()+"<br>Result is "+result.toString()); // +"<br>A is "+result.plus(vecAx).toString());
	return result;
}
function find_vecA_old(vecAx, vecBasis,R,BA)
{
	var B0 = vecBasis.norm();
	var unitBasis = vecBasis.times(1/B0);
	// var unitAx = vecAx.times(1/vecAx.norm());
	var unitOrtho = vecBasis.op(vecAx).unit(); // unit vector orthogonal to vecBasis and vecAx
	// var unitOrtho = vecOrtho.times(1/vecOrtho.norm());

	var cosBA = cosine(BA,B0,R);
	var sinBA = Math.sqrt(1-cosBA*cosBA);

	var result =  unitBasis.times(cosBA*R).plus(unitOrtho.times(sinBA*R));
	
 	// alert ("<br>0<B0+R-BA = "+(B0+R-BA)+"<br>cosine is cosBA = "+cosBA+"<br>B0 = "+B0+"<br>BA = "+BA+"<br>R = "+R+"<br>unitAx is "+unitAx.toString()+"<br>unitBAsis is "+unitBasis.toString()+"<br>unitOrtho is "+unitOrtho.toString()+"<br>Result is "+result.toString()); // +"<br>A is "+result.plus(vecAx).toString());
	return result;
}

/* perform repeated small rotation around x and z axis
*/
function Matrix_rotate(M_in,nPhi,nTheta)
{
	var N = 20; // 20 small rotations along 2 different axes
	
	var delta = 0.02 ;// standard angle of rotation, in radians
	deltaPhi = delta * nPhi/N;
	deltaTheta = - delta * nTheta/N; // negative, because y-coordinates are mirrored in svg
	cosP = Math.cos(deltaPhi);
	sinP = Math.sin(deltaPhi);
	cosT = Math.cos(deltaTheta);
	sinT = Math.sin(deltaTheta);

	// the generators of the rotations
	// = matrices for small rotations
	// theta: rotate along z axis 
	M_theta = [ [ cosT, sinT  , 0],
		    [ -sinT , cosT  , 0],
		    [     0,   0   , 1] ];
	// phi: rotate along y axis
	M_phi = [ [ cosP, 0, sinP],
		  [ 0,    1,   0 ],
		  [ -sinP,0, cosP] ];
   	M_combined = MatrixUtil.Multiply(M_theta,M_phi); 
	// displayText += "Mcombined is "+MatrixUtil.AsHMTL(M_combined);
	// for small values of delta, M_theta x M_phi = M_phi x M_theta
	var M = M_in
	for (let k =0; k<N; k++)
	{
		M = MatrixUtil.Multiply(M_combined,M);
	}
	// make the rows orthonormal, because
        // after many rotations, round-off errors may have accumulated
	for(var i = 0; i<M.length; i++)
        {
               for (var j = 0; j<i; j++)
               { 
                        M[i]=VectorUtil.Subtract(M[i],
                               VectorUtil.TimesScalar(M[j],
                                 VectorUtil.InnerProduct(M[i],M[j])));
               }
        }
	return M;
}

/** param {svgObject} svg - a reference tot the svgObject 
 * param {array} from - x,y,z
 * param { array} to - x, y , z
 */

function lineSegment(svgObject,from,to, color)
   {
   	this.from = from; // [x,y,z]
   	this.to = to; // [x,y,z]

	this.element = document.createElementNS(svgNameSpace, 'path'); //Create a path in SVG's namespace
	this.element.style.stroke = color; //Set stroke colour
	this.element.style.strokeWidth = "2px"; //Set stroke width
	
   	this.setAtrb=function(attribute,value)
	   {	this.element.setAttributeNS(null,attribute,value);
	   }
   	/** @params {array} M_rotation - 3 x 3 matrix
   	*   @params {array} center - 	the center of the rotation, and of the projection
   	*/

   	this.project = function(M_rotation,center)
   	{	var from = VectorUtil.Subtract(this.from,center);
			from =MatrixUtil.TimesVector(M_rotation,from);
   		var to = VectorUtil.Subtract(this.to,center);
   			to = MatrixUtil.TimesVector(M_rotation,to);
		var pathDef = "M "+from[0]+" "+from[1]+" "+to[0]+" "+to[1]+" ";
		this.element.setAttribute("d",pathDef); //Set path's data
	}
   }
/** param {svgObject} svg - a reference tot the svgObject 
 * param {array} from - x,y,z
 * param { array} to - x, y , z
 */

function svgText(svgObject,coordinates,text, color)
   {
	this.element = document.createElementNS(svgNameSpace, 'text'); //Create a text in SVG's namespace

   	this.setAtrb=function(attribute,value)
	   {	this.element.setAttributeNS(null,attribute,value);
	   }

   	this.coord = coordinates; // [x,y,z]

	this.element.style.stroke = color; //Set stroke colour
	this.element.style.strokeWidth = "0.3px"; //Set stroke width
	this.element.textContent = text;
	this.setAtrb("font-family","sans-serif")
	this.setAtrb("font-size",5)
	this.setAtrb("x",coordinates[0])
	this.setAtrb("y",coordinates[1])
	
	this.setText= function(text)
	{	this.element.textContent = text;
	}

   	/** @params {array} M_rotation - 3 x 3 matrix
   	*   @params {array} center - 	the center of the rotation, and of the projection
   	*/

   	this.project = function(M_rotation,center)
   	{	var coord = VectorUtil.Subtract(this.coord,center);
			coord =MatrixUtil.TimesVector(M_rotation,coord);
   		this.setAtrb("x",coord[0])
   		this.setAtrb("y",coord[1])
	}
   }

function svgObjects(svgId)
{
	// private variables
	var svg = document.getElementById(svgId); //Get svg element
	var Mat_orient =	[ [-1,  0  , 0],
		[   0, 1  , 0],
		[   0,   0   , -1] ];  
	var Mat_projection_init =	[ [ 0,  0  , 1],
		[   0, -1  , 0],
		[   0,   0   , 0] ];

	var Mat_projection = MatrixUtil.Multiply(Mat_projection_init,Mat_orient);

	this.svg = function ()
	{	return svg;
	}
	// because positive y is down on the screen
	var that = this; 

	center = [20,20,20]

	this.setCenter=function(xyz)
		{       if (3 == xyz.length)
		        {       center = xyz;
		        }
		}
        this.elements = []; // array of lineSegments

	this.addCircle = function(center, color)
        {};
        
        this.addSegment = function (from,to,color)
	{
		let count = this.elements.length;
		this.elements[count] = new lineSegment(that,from,to,color);
		svg.appendChild(this.elements[count].element);
		this.elements[count].project(Mat_projection,center);
                return this.elements[count]; // return a handle to the segment
	}
	this.addText = function (coord,text,color)
	{
		let count = this.elements.length;
		this.elements[count] = new svgText(that,coord,text,color);
		svg.appendChild(this.elements[count].element);
		this.elements[count].project(Mat_projection,center);
                return this.elements[count]; // return a handle to the segment
	}
	this.rotate = function(down,right)
	{
		Mat_orient = Matrix_rotate(Mat_orient, down,right);
                Mat_projection = MatrixUtil.Multiply(Mat_projection_init,Mat_orient);
   		this.project();
	}

	this.project = function()
	{
   		for( let i = 0; i<this.elements.length; i++)
   		{
		this.elements[i].project(Mat_projection,center);
   		}
	}

}
axisSVG = new svgObjects("3Dscreen");
{	let axisColor = "#933";
	let axL = 15;
	let labelDist = 15;

	let originShift = new vector([-20,0,80])
	let origin = new vector([0,0,0]).plus(originShift)
	let xAxis = new vector([axL,0,0]).plus(originShift)
	let yAxis = new vector([0,axL,0]).plus(originShift)
	let zAxis = new vector([0,0,axL]).plus(originShift)

	axisSVG.addSegment(origin.vector,xAxis.vector,axisColor)
	axisSVG.addSegment(origin.vector,yAxis.vector,axisColor)
	axisSVG.addSegment(origin.vector,zAxis.vector,axisColor)

	let xAxisLabelCoord = new vector([labelDist,0,0]).plus(originShift)
	let yAxisLabelCoord = new vector([0,labelDist,0]).plus(originShift)
	let zAxisLabelCoord = new vector([0,0,labelDist]).plus(originShift)

	axisSVG.addText(xAxisLabelCoord.vector,"X",axisColor)
	axisSVG.addText(yAxisLabelCoord.vector,"Y",axisColor)
	axisSVG.addText(zAxisLabelCoord.vector,"Z",axisColor)
	
}

resultSvg = new svgObjects("3Dscreen");
resultSvg.setCenter([15,20,30]); 
resultSvg.rotate(8,5);
axisSVG.rotate(8,5);
var mouseX, mouseY;


svg = resultSvg.svg();
   svg.setAttributeNS(null,'onmousedown',"mouseIsDown(evt)");
   svg.setAttributeNS(null,'onmouseup',"mouseIsUp(evt)");
function mouseIsDown(e)
{	
  	takeCoordinates(e)
	svg.setAttributeNS(null,'onmousemove',"mouseHasMoved(evt)");
}
function takeCoordinates(e)
{
	mouseX =   e.clientX||e.changedTouches[0].clientX;
	mouseY =   e.clientY||e.changedTouches[0].clientY;
}
function mouseIsUp(e)
{
   svg.setAttributeNS(null,'onmousemove',null);
}
function mouseHasMoved(e)
{
	oldX= mouseX;
	oldY= mouseY;
	takeCoordinates(e)
	resultSvg.rotate(mouseX-oldX,mouseY-oldY);
	axisSVG.rotate(mouseX-oldX,mouseY-oldY);
}

/** param {number} nIterations - an integer
* param {number} B0 - distance from B5 to the axis B1-B2 (roughly under A)
* param {number} R - initial guess for AD
* param {number} BA - initial guess for BA
* param {vector} vecAD - for the moment, a constant value
* find the correct coordinates for A, based on B0 and R and B5D.
*/

function solveB5(params)
{
	var nIterations = params.nIterations;
	var R1 = params.R1;
	var R2 = params.R2;
	var R3 = params.R3;
	var R4 = params.R4;
	var B5D = params.B5D;
	var AB = params.AB;
	var AC = params.AC;
	var vecBD_init = params.vecBD_init ;
	var vecBD = params.vecBD_init ;
	var BD = vecBD.norm();

	var vecA;
	var infoText = "<hr>";

	var B5toA = B5D; // intial estimate for BA, e.g. BA =B5D
	var settings = { R1:R1, R2:R2, R3:R3, R4:R4, R5: B5D,
			 AC:AC, AB: AB, BD:BD, 
			 b1:b1, b2:b2, b3:b3, b4:b4, b5:b5,
			 estimates:{B5toA:B5toA, vecBD:vecBD}
			}
	settingText = "Settings: "
/*	settingText += "<br>R1 = "+R1;
	settingText += "<br>R2 = "+R2;
	settingText += "<br>R3 = "+R3;
	settingText += "<br>R4 = "+R4;
	settingText += "<br>R5 = "+B5D;
	settingText += "<br>fixed distances :";
	settingText += "<br>AC = "+AC;
	settingText += "<br>AB = "+AB;
	settingText += "<br>BD = "+vecBD_init.norm();
	settingText += "<br>fixed positions :";
	settingText += "<br>b1 = "+b1;
	settingText += "<br>b2 = "+b2;
	settingText += "<br>b3 = "+b3;
	settingText += "<br>b4 = "+b4;
	settingText += "<br>b5 = "+b5;
	settingText += "<hr>";
*/
	
	infoText += "We will start the iteration with B5toA = "+ B5toA +"<br>";
	var vectorAxis = b4.minus(b3); // b4.minus(b3) gives the wrong orientation

	// var triangleInfo_A = axisPoint(vectorAxis, R3,R4);// Axis points from b3 to b4
	var triangleInfo_A = footOnAxis(b3,b4, R3,R4, "B5-D", "R3","R4");// the foot of A on the axis
	var foot_A = triangleInfo_A.footVec.plus(b3);
	var B5_projected = b5.minus(foot_A).projectOn(vectorAxis)
	let basisVec = b5.minus(foot_A).minus(B5_projected) // b5+(vecC-b5)pO(axis)-veC
	
	var vectorAxis_C = b1.minus(b2); // b2.minus(b3) gives the wrong orientation in find_vec
	//	var triangleInfo_C = axisPoint(vectorAxis_C, R1,R2);// Axis points from b1 to b2
	var triangleInfo_C = footOnAxis(b1,b2, R1,R2,"A-C","R1","R2");// Axis points from b1 to b2
	var foot_C = triangleInfo_C.footVec.plus(b1);
	var hC = triangleInfo_C.H;

	// By definition of b1 and b2, foot_C has y=0 and z=0
	
	/*	infoText += "H : "+triangleInfo_A.H+"<br>";	
	infoText += "||A|| according to triangle: "+Math.sqrt(Math.pow(triangleInfo_A.H,2)+Math.pow(triangleInfo_A.footVec.norm(),2))+"<br>";
		infoText += "vectorAxis is : "+ vectorAxis.toString()+"<br>";
		infoText += "b5 is : "+ b5.toString()+"<br>";
		infoText += "b5 projected is : "+ B5_projected.toString()+"<br>";
		infoText += "basisVec is : "+ basisVec.toString()+"<br>";
		infoText += "B5 axial is : "+ B5_projected.norm()+"<br>";
		infoText += " Basis_vec must be ortho to axis: ip = "+basisVec.ip(vectorAxis)+"<br>";
		infoText += "foot_A is : "+ foot_A.toString()+"<br>";
		infoText += "foot_A-b5 is : "+ foot_A.minus(b5).toString()+"<br>";
	infoText += "vectorAxis_C is : "+ vectorAxis_C.toString()+"<br>";
	infoText += "R1 is : "+ R1+"<br>";
	infoText += "R2 is : "+ R2+"<br>";
	infoText += "foot_C is : "+ foot_C.toString()+"<br>";
	infoText += "hC is : "+ hC+"<br>";
	*/

	var results = []
	for (var j = 0; j<nIterations ; j++)
	{
		results.B5toA = B5toA;
		infoText += "<hr>iteration = "+ j+"<br>";
		infoText += "B5toA: "+B5toA+" <br>";
		// estimate A
		vecA = find_vec(vectorAxis,basisVec,triangleInfo_A.H,B5toA,B5_projected.norm(), "A","B to A","H of A").plus(foot_A);	

		// calculate C
		let A_projected = vecA.minus(foot_C).projectOn(vectorAxis_C) // A might change at each iteration, but the projection should not change
		let basisVec_A = vecA.minus(foot_C).minus(A_projected) // from A to the axis of C

		var vecC = find_vec(vectorAxis_C,basisVec_A,triangleInfo_C.H,AC,A_projected.norm(), "C", "AC", " hC ").plus(foot_C);	
		// calculate B, between A and C
		var vecB = vecA.times(1-AB/AC).plus(vecC.times(AB/AC));
		var vecD = vecB.plus(vecBD);

		var vecAC = vecC.minus(vecA)

		// axis J13 is parallel to J14, J15 is perpendicular to J13 and to AC
		// J15 = AC x (Db5 x b1b2)
		// repetition of this loop is useless. For a better estimation of vecD, vecA and vecB must also be re-calculated.
		{	
			var J13 = vecD.minus(b5).op(vectorAxis_C).unit()
			var J15 = vecAC.op(J13).unit()
			let calcResults = {iteration: j,
					B5toA: B5toA,
					vecA: vecA.copy(), vecB:vecB.copy(), vecC:vecC.copy(), vecDEstimated:vecD.copy(),
					J14:J13.copy(), J15:J15.copy()
					};
			vecBD = vecAC.op(J15).unit().times(BD)
			vecBD_alt = vecAC.op(vecAC.op(vecA.minus(b5))).unit().times(BD) // perpendicular to AC, in the plane of A, C and B5
			// estimate D		
			vecD = vecB.plus(vecBD); // corresponds to the orientation of J15 and J14 and J13
			calcResults.vecD= vecD.copy();
			results[results.length] = calcResults;		
		}
		
		// checkText += "<br>j = "+j+" b5-D . J13 = " + b5.minus(vecD).ip(J13)
		// var vecD_alternative = vecB_alt.plus(vecBD_alt); // not correct - this will be a more complicated function, setting the J14 axis parallel to J13

		// set a better value for BA for the nex approximation
		B5toA = estimate_BA(B5D,b5,vecA,vecD);

		/*var vecC_alt = new vector([foot_C.vector[0], yC, z])
		var vecC_check = vecC_alt.minus(vecC)		
		var vecA_check = vecA_alt.minus(vecA)		
		infoText += "A : "+ vecA.toString()+"<br>";
		infoText += "C : "+ vecC.toString()+"<br>";
		// infoText += "C alt : "+ vecC_alternative.toString()+"<br>";
		// infoText += "C check : "+ vecC_check.toString()+"<br>";
		infoText += "B : "+ vecB.toString()+"<br>";
		infoText += "D: "+vecD.toString()+" <br>";
		*/
		
	}



	
	// axis J5? is parallel to axis from B5
	return { vecA: vecA,
		 vecB: vecB,
		 vecC: vecC,
		 vecD:vecD,
		 // err2: err2,
		 text: infoText,
		 settingText: settingText,
		 settings: settings,
		 results:results,
		// checkText: checkText
		};
}

function performChecks(settings,results)
{
	vecA = results.vecA;
	vecB= results.vecB;
	vecC = results.vecC;
	vecD = results.vecD;

	vecBD = vecD.minus(vecB);
	vecAB = vecB.minus(vecA);
	vecAC = vecC.minus(vecA);
	// perform checks
	var prec = 5; // precision for displaying numbers
	var error2Sum = 0;
	var checkText = "";

	// R1, R2, R3, R4, R5=B5D
	let err = b1.minus(vecC).norm()-settings.R1; error2Sum += err*err;
	checkText += "from B1 to C :"+b1.minus(vecC).norm().toFixed(prec)+" - "+settings.R1.toFixed(prec) +" = "+err;
	err = b2.minus(vecC).norm()-settings.R2; error2Sum += err*err;
	checkText += "<br>from B2 to C :"+b2.minus(vecC).norm().toFixed(prec)+" - "+settings.R2.toFixed(prec) +" = "+err;
	err = b3.minus(vecA).norm()-settings.R3; error2Sum += err*err;
	checkText += "<br>from B3 to A :"+b3.minus(vecA).norm().toFixed(prec)+" - "+settings.R3.toFixed(prec) +" = "+err;
	err = b4.minus(vecA).norm()-settings.R4; error2Sum += err*err;
	checkText += "<br>from B4 to A :"+b4.minus(vecA).norm().toFixed(prec)+" - "+settings.R4.toFixed(prec) +" = "+err;
	err = b5.minus(vecD).norm()-settings.R5; error2Sum += err*err;
	checkText += "<br>from B5 to D :"+b5.minus(vecD).norm().toFixed(prec)+" - "+settings.R5.toFixed(prec) +" = "+err;
	// AB, AC, BD
	err = vecB.minus(vecA).norm()-AB; error2Sum += err*err;
	checkText += "<br>from A to B :"+vecB.minus(vecA).norm().toFixed(prec)+" - "+AB.toFixed(prec) +" = "+err;
	err = vecC.minus(vecA).norm()-AC; error2Sum += err*err;
	checkText += "<br>from A to C :"+vecC.minus(vecA).norm().toFixed(prec)+" - "+AC.toFixed(prec) +" = "+err;
	err = vecB.minus(vecC).norm()-(AC-AB); error2Sum += err*err;
	checkText += "<br>from B to C :"+vecB.minus(vecC).norm().toFixed(prec)+" - "+(AC-AB).toFixed(prec) +" = "+err;
	err = vecB.minus(vecD).norm()-BD; error2Sum += err*err;
	checkText += "<br>from B to D :"+vecB.minus(vecD).norm().toFixed(prec)+" - "+BD.toFixed(prec) +" = "+err;
	err2 = Math.sqrt(error2Sum);
	checkText += "<br>sqrt(sum(error^2)):"+err2
	checkText += "<br>orthogonality of axes:"
	checkText += "<br> BD . AC = " + vecBD.ip(vecAC)
	checkText += "<br> AC . J15 = " + vecAC.ip(results.J15)
	checkText += "<br> BD . J15 = " + vecBD.ip(results.J15)
	checkText += "<br> b5-D . J13 = " + b5.minus(vecD).ip(results.J14)
	
	return { text:checkText, err2:err2};	
}

function resultString(settings, results)
{
	result = "number of iterations: "+results.length;
	for (var j=results.length-2; 0<=j;  j--)
	{
		checked = performChecks(settings, results[j])
		 result+= "<hr>";
		result += "iteration: "+results[j].iteration;
		result += "<br> error: "+checked.err2;
		result += "<br> from B5 to A :"+results[j].B5toA;
		result += "<br> coordinates :";
		result += "<br> A ="+results[j].vecA.toString(5);	
		result += "<br> B ="+results[j].vecB.toString(5);	
		result += "<br> C ="+results[j].vecC.toString(5);	
		result += "<br> D ="+results[j].vecD.toString(5);
		result += "<br> orientations :";
		result += "<br> J14 ="+results[j].J14.toString(5);
		result += "<br> J15 ="+results[j].J15.toString(5);
		if (0<j)
		{
			result += "<br> changes :";
			result += "<br> change in A = "+results[j].vecA.minus(results[j-1].vecA).times(1/results[j].vecA.norm())
			result += "<br> change in B = "+results[j].vecB.minus(results[j-1].vecB).times(1/results[j].vecB.norm())
			result += "<br> change in C = "+results[j].vecC.minus(results[j-1].vecC).times(1/results[j].vecC.norm())
			result += "<br> change in D = "+results[j].vecD.minus(results[j-1].vecD).times(1/results[j].vecD.norm())
			result += "<br> change in J14 = "+results[j].J14.minus(results[j-1].J14)
			result += "<br> change in J15 = "+results[j].J15.minus(results[j-1].J15)
		}
			result += "<br> <b>precision</b>:<br>"+checked.text;
	}
	return result;
}
function axisPoint(axVector, adjacentL, oppositeL)
{
	cosPhi = cosine(oppositeL, adjacentL,axVector.norm());
	B = cosPhi*adjacentL;
	R = adjacentL*(Math.sqrt(1-cosPhi*cosPhi));

	Center = axVector.times(B/axVector.norm());

	return { H: R, footVec: Center}
}

/* param {vector} axStart
   param {vector} axEnd
   param {Number} adjacentL
   param {Number} oppositeL
   param {String} labelToSummit
   param {String} labelAdj
   param {String} labelOpp
*/    
function footOnAxis(axStart, axEnd, adjacentL, oppositeL, labelToSummit, labelAdj, labelOpp)
{
	var axVector = axEnd.minus(axStart);

	try
	{
		cosPhi = cosine(oppositeL, adjacentL,axVector.norm());
	}
	catch (exception)
	{
	  	handleCosineError(exception,"Axis for "+labelToSummit, labelAdj, labelOpp, axVector.norm(),adjacentL,oppositeL)
	}	
	B = cosPhi*adjacentL;
	R = adjacentL*(Math.sqrt(1-cosPhi*cosPhi));

	Center = axVector.times(B/axVector.norm());
	return { axisVec: axVector,
		 H: R,
		 footVec: Center};
}

function handleCosineError(exception,labelAdj1, labelAdj2, labelOpp, adjacent1L, adjacent2L, oppositeL)
{
  	if (exception instanceof CosineError)
	{
		if (exception.tooBig)
		{	message = "Can't construct triangle "+labelAdj1+"-"+labelAdj2+"-"+labelOpp+", "+labelOpp+" is too big compared to "+labelAdj2+" ("+oppositeL+" vs "+adjacent2L+"). ";
		}
		else
		{	message = "Can't construct triangle "+labelAdj1+"-"+labelAdj2+"-"+labelOpp+", try a bigger value for "+labelOpp+" (currently "+oppositeL+" ). ";
		}
		//	exception.addMessage(message); throw (exception);
		alert(message+exception.message)
		throw (new Error (message + exception.message));
	}
	else 
	{	throw (exception)
	}
}

/* solve c0 + c1 y +c2 y^2 = 0 
note: will return 2 solutions in an array, 
this will be NaN if no (real) solutions are possible
*/
function quadraticRoot_old(c0,c1,c2)
{
	if (c1*c1 < 4*c0*c2)
	{ alert (" impossible root: "+[c0,c1,c2]);
	}
	var D = Math.sqrt(c1*c1 - 4*c0*c2);
	
	var result = [];
	result[0] = 0.5 * (-c1 - D)/c2;
	result[1] = 0.5 * (-c1 + D)/c2;
	return result	;
}

function quadraticRoot(c0,c1,c2)
{
	if (c1*c1 < 4*c0*c2)
	{ alert (" impossible root: "+[c0,c1,c2]);
	}
	var g = 0.5*c1/c2;

	var D = Math.sqrt(g*g - c0/c2);
	
	var result = [];
	result[0] = -g-D;
	result[1] = -g+D;
	return result	;
}

createStormram = function(svgObject, b1,b2,b3,b4,b5)
{
	labelDistance = 5; // distance from a label to a point

        pistonColor = "#00A";
	textColor = "#222";

	// unknown vectors will obtain a value in this.update

	unknown = new vector([0,0,0]);

        b1C_segment = svgObject.addSegment(b1.vector,unknown.vector,pistonColor);
        b2C_segment = svgObject.addSegment(b2.vector,unknown.vector,pistonColor);
        b3A_segment = svgObject.addSegment(b3.vector,unknown.vector,pistonColor);
        b4A_segment = svgObject.addSegment(b4.vector,unknown.vector,pistonColor);
        b5B_segment = svgObject.addSegment(b5.vector,unknown.vector,pistonColor);

	b1Letter = svgObject.addText(b1.plus(new vector( [-labelDistance,-labelDistance,0])).vector,"B1",textColor);
	b2Letter = svgObject.addText(b2.plus(new vector( [labelDistance,-labelDistance,0])).vector,"B2",textColor);
	b3Letter = svgObject.addText(b3.plus(new vector( [-labelDistance,-labelDistance,0])).vector,"B3",textColor);
	b4Letter = svgObject.addText(b4.plus(new vector( [labelDistance,-labelDistance,0])).vector,"B4",textColor);
	b5Letter = svgObject.addText(b5.plus(new vector( [0,-labelDistance,-labelDistance])).vector,"B5",textColor);

	aLabelShift = new vector( [0,labelDistance,labelDistance])
	bLabelShift = new vector( [0,labelDistance,0])
	cLabelShift = new vector( [0,labelDistance,-labelDistance])
	dLabelShift = new vector( [0,-labelDistance,0])
	
	aLetter = svgObject.addText(unknown.vector,"A",textColor);
	bLetter = svgObject.addText(unknown.vector,"B",textColor);
	cLetter = svgObject.addText(unknown.vector,"C",textColor);
	dLetter = svgObject.addText(unknown.vector,"D",textColor);

        connectionColor = "#2FF"
        AC_segment = svgObject.addSegment(unknown.vector,unknown.vector,connectionColor);
        DB_segment = svgObject.addSegment(unknown.vector,unknown.vector,"#800");

        svgObject.project();

        this.update = function(vectorA,vectorC,vectorD,vectorB)
        {
        AC_segment.from = vectorA.vector;
        DB_segment.from = vectorD.vector;
        AC_segment.to = vectorC.vector;
        DB_segment.to = vectorB.vector;

        b1C_segment.to = vectorC.vector;
        b2C_segment.to = vectorC.vector;
        b3A_segment.to = vectorA.vector;
        b4A_segment.to = vectorA.vector;
        b5B_segment.to = vectorD.vector;

	aLetter.coord = vectorA.plus(aLabelShift).vector;
	bLetter.coord = vectorB.plus(bLabelShift).vector;
	cLetter.coord = vectorC.plus(cLabelShift).vector;
	dLetter.coord = vectorD.plus(dLabelShift).vector;
        svgObject.project();
        }
}

var stormram = new createStormram(resultSvg, b1,b2,b3,b4,b5)
var displayText = "";

var configuration = { nIterations: 30,
		R1: 70,// vectorC.minus(b1).norm(), 
		R2: 100,//vectorC.minus(b2).norm(),
		R3: 76,// vectorA.minus(b3).norm(),
		R4: 66,// vectorA.minus(b4).norm(),
		B5D :85,//  B5D,
		AB : AB,
		AC : AC, // vectorA.minus(vectorC).norm()
		vecBD_init : new vector([0,-BD,0])
};

var solution = solveB5(configuration);
var stormram = stormram.update(solution.vecA,solution.vecC,solution.vecD,solution.vecB)

document.getElementById("parameters").innerHTML =  solution.settingText;
document.getElementById("precision").innerHTML =  performChecks(solution.settings, solution.results[solution.results.length-1]).text;
document.getElementById("text_out").innerHTML =  displayText+ solution.text;
document.getElementById("text_out").innerHTML =  resultString(solution.settings, solution.results)

/* m.b.t. de plaatjes, draaien etc:

- rotation:
The projection from 3D to 2D is a parallel projection.
So essentially, just the x and y coordinates,
after the rotation has been performed.

Rotations are the product of small rotations along y-axis (phi) 
and x-axis (theta).
The resulting rotation matrix is stored, and when state=="rotate"
this matrix is updated every time when the mouse is moved.
*/
</script>

</body>
</html>

</script>
