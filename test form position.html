<html>
<!DOCTYPE html>

<HEAD> 
<TITLE>stormram calculation</TITLE></HEAD>
<body>

<form name="paramsForm" action='nothing.php' onChange="treatForm(); return false;">

<table border="0" cellpadding="5" cellspacing="0">
<tr>
	<td>    R1 (from B1 to C)</td>
	<td>    R2 (from B2 to C)</td>
	<td>    R3 (from B3 to A)</td>
	<td>    R4 (from B4 to A)</td>
	<td>    R5 (from B5 to D)</td>
</tr>
<tr>
	<td>	<input name="R1" value="70" min="40" max="120" type="number">	</td>
	<td>	<input name="R2" value="70" min="40" max="120" type="number">	</td>
	<td>	<input name="R3" value="75" min="40" max="120" type="number">	</td>
	<td>	<input name="R4" value="75" min="40" max="120" type="number">	</td>
	<td>	<input name="R5" value="85" min="40" max="160" type="number">	</td>
</tr>
</table>
</form>

<link rel="stylesheet" type="text/css" href="./index.css" /> 

  <!--script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script-->


<p id="pict_out">
<svg id="3Dscreen" width="400" height="400" viewbox="-80 -50 130 150" onmousedown='alert("No function is activated by clicking the mouse.")'>
</svg>
</p>
<p id="message" note="for error messages etc">(click on the picture to rotate it - note that the orientation of the axes is taken from fig. 6.7)</p><hr>

<h3>Parameters</h3>
<p id="parameters"></p>
<h3>Precision of the results</h3>
<p id="precision"></p>
<h3>Results</h3>
<p id="text_out"></p>

<script type="text/javascript" src="js/MatrixUtil2.js"></script>
<script type="text/javascript" src="js/VectorUtil.js"></script>
<script type="text/javascript" src="js/classVector.js"></script>
<script type="text/javascript" src="js/stormramSolve.js"></script>
<script type="text/javascript" src="js/svgFunctions.js"></script>
<script type="text/javascript" src="js/Error.js"></script>
<script>

axisSVG = new svgObjects("3Dscreen");
{	let axisColor = "#933";
	let axL = 15;
	let labelDist = 15;

	let originShift = new vector([-20,0,80])
	let origin = new vector([0,0,0]).plus(originShift)
	let xAxis = new vector([axL,0,0]).plus(originShift)
	let yAxis = new vector([0,axL,0]).plus(originShift)
	let zAxis = new vector([0,0,axL]).plus(originShift)

	axisSVG.addSegment(origin.vector,xAxis.vector,axisColor)
	axisSVG.addSegment(origin.vector,yAxis.vector,axisColor)
	axisSVG.addSegment(origin.vector,zAxis.vector,axisColor)

	let xAxisLabelCoord = new vector([labelDist,0,0]).plus(originShift)
	let yAxisLabelCoord = new vector([0,labelDist,0]).plus(originShift)
	let zAxisLabelCoord = new vector([0,0,labelDist]).plus(originShift)

	axisSVG.addText(xAxisLabelCoord.vector,"X",axisColor)
	axisSVG.addText(yAxisLabelCoord.vector,"Y",axisColor)
	axisSVG.addText(zAxisLabelCoord.vector,"Z",axisColor)
	
}

resultSvg = new svgObjects("3Dscreen");
resultSvg.setCenter([15,20,30]); 
resultSvg.rotate(8,5);
axisSVG.rotate(8,5);

svg = resultSvg.svg();
   svg.setAttributeNS(null,'onmousedown',"mouseIsDown(evt)");
   svg.setAttributeNS(null,'onmouseup',"mouseIsUp(evt)");

createStormram = function(svgObject, b1,b2,b3,b4,b5)
{
	labelDistance = 5; // distance from a label to a point

        pistonColor = "#00A";
	textColor = "#222";

	// unknown vectors will obtain a value in this.update

	unknown = new vector([0,0,0]);

        b1C_segment = svgObject.addSegment(b1.vector,unknown.vector,pistonColor);
        b2C_segment = svgObject.addSegment(b2.vector,unknown.vector,pistonColor);
        b3A_segment = svgObject.addSegment(b3.vector,unknown.vector,pistonColor);
        b4A_segment = svgObject.addSegment(b4.vector,unknown.vector,pistonColor);
        b5B_segment = svgObject.addSegment(b5.vector,unknown.vector,pistonColor);

	b1Letter = svgObject.addText(b1.plus(new vector( [-labelDistance,-labelDistance,0])).vector,"B1",textColor);
	b2Letter = svgObject.addText(b2.plus(new vector( [labelDistance,-labelDistance,0])).vector,"B2",textColor);
	b3Letter = svgObject.addText(b3.plus(new vector( [-labelDistance,-labelDistance,0])).vector,"B3",textColor);
	b4Letter = svgObject.addText(b4.plus(new vector( [labelDistance,-labelDistance,0])).vector,"B4",textColor);
	b5Letter = svgObject.addText(b5.plus(new vector( [0,-labelDistance,-labelDistance])).vector,"B5",textColor);

	aLabelShift = new vector( [0,labelDistance,labelDistance])
	bLabelShift = new vector( [0,labelDistance,0])
	cLabelShift = new vector( [0,labelDistance,-labelDistance])
	dLabelShift = new vector( [0,-labelDistance,0])
	
	aLetter = svgObject.addText(unknown.vector,"A",textColor);
	bLetter = svgObject.addText(unknown.vector,"B",textColor);
	cLetter = svgObject.addText(unknown.vector,"C",textColor);
	dLetter = svgObject.addText(unknown.vector,"D",textColor);

        connectionColor = "#2FF"
        AC_segment = svgObject.addSegment(unknown.vector,unknown.vector,connectionColor);
        DB_segment = svgObject.addSegment(unknown.vector,unknown.vector,"#800");

        svgObject.project();

        this.update = function(vectorA,vectorC,vectorD,vectorB)
        {
        AC_segment.from = vectorA.vector;
        DB_segment.from = vectorD.vector;
        AC_segment.to = vectorC.vector;
        DB_segment.to = vectorB.vector;

        b1C_segment.to = vectorC.vector;
        b2C_segment.to = vectorC.vector;
        b3A_segment.to = vectorA.vector;
        b4A_segment.to = vectorA.vector;
        b5B_segment.to = vectorD.vector;

	aLetter.coord = vectorA.plus(aLabelShift).vector;
	bLetter.coord = vectorB.plus(bLabelShift).vector;
	cLetter.coord = vectorC.plus(cLabelShift).vector;
	dLetter.coord = vectorD.plus(dLabelShift).vector;
        svgObject.project();
        }
}

var stormram = new createStormram(resultSvg, b1,b2,b3,b4,b5)
// var displayText = "";
treatForm();

/*var configuration = { nIterations: 30,
		R1: 70,// vectorC.minus(b1).norm(), 
		R2: 100,//vectorC.minus(b2).norm(),
		R3: 76,// vectorA.minus(b3).norm(),
		R4: 66,// vectorA.minus(b4).norm(),
		B5D :85,//  B5D,
		// AB : AB,
		// AC : AC, // vectorA.minus(vectorC).norm()
		// 
};
solve (configuration,true)
*/
function treatForm()
{
	var form = document.forms["paramsForm"];

	names = [ "R1","R2","R3","R4","R5"]
	message = ""
	for(i=0;i<names.length;i++)
	{message+= names[i]+": "+form[names[i]].value+" , "
	}
	// alert( message)
	var params = { nIterations: 30,
			R1: form["R1"].value*1, // vectorC.minus(b1).norm(), 
			R2: form["R2"].value*1, //vectorC.minus(b2).norm(),
			R3: form["R3"].value*1, // vectorA.minus(b3).norm(),
			R4: form["R4"].value*1, // vectorA.minus(b4).norm(),
			B5D :form["R5"].value*1 //  B5D
			};
	solve(params, false)
}
function solve(configuration, showDetails)
{	
	if (null == showDetails)
	{	showDetails = false;
	}	
	var solution = solveABCD(configuration);
	stormram.update(solution.vecA,solution.vecC,solution.vecD,solution.vecB)

	if (showDetails)
	{
		document.getElementById("parameters").innerHTML =  solution.settingText;
		document.getElementById("precision").innerHTML =  performChecks(solution.settings, solution.results[solution.results.length-1]).text;
		// document.getElementById("text_out").innerHTML =  displayText+ solution.text;
		document.getElementById("text_out").innerHTML =  resultString(solution.settings, solution.results)
	}
}
/* m.b.t. de plaatjes, draaien etc:

- rotation:
The projection from 3D to 2D is a parallel projection.
So essentially, just the x and y coordinates,
after the rotation has been performed.

Rotations are the product of small rotations along y-axis (phi) 
and x-axis (theta).
The resulting rotation matrix is stored, and when state=="rotate"
this matrix is updated every time when the mouse is moved.
*/
</script>

</body>
</html>
